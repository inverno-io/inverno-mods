[xslt]: https://en.wikipedia.org/wiki/XSLT
[erlang]: https://en.wikipedia.org/wiki/Erlang_(programming_language)
[template-benchmark]: https://github.com/jkuhn1/template-benchmark

# Reactive Template

The Inverno *reactive template* module provides a template engine for efficient reactive data rendering.

Data are basically rendered by templates which are regrouped in template sets and applied based on the type of data to render. A template set is statically typed and generated by an Inverno compiler plugin which compiles `.irt` template set source files along with the Java sources of a module.

The template sets classes thus obtained support reactive rendering, data are rendered as a flow of events for efficient usage of resources. For instance, the complete set of data doesn't have to be available or loaded into memory, the rendering being reactive the output can be generated incrementally by processing each piece of data individually one after the other when they become available. Since the rendering process never blocks it is also possible to lazily load data when/if they need to be rendered.

The syntax of `.irt` template set is inspired from functional language such as [XSLT][xslt] and [Erlang][erlang] which are particularly suited for reactive rendering. Since a template is a generated Java class, the Java language is also widely used in a template source file, especially for the dynamic parts of a template.

In terms of raw performance, Inverno templates processing is faster than most Java template engines by an order of magnitude and with lower memory usage. The following [benchmark project][template-benchmark] compares performances of various template engines rendering a list of stock items into an HTML document as a String. 

<img class="shadow mb-4 mx-auto d-block" src="doc/img/template_benchmarks.png" alt="Template Benchmarks"/>

> Please keep in mind that outcomes might be different considering different scenarios, especially reactive rendering which might appear slower but addresses different concerns such as stream processing and optimized usage of resources.

In order to use the Inverno *reactive template* module, we need to declare a dependency in the module descriptor:

```java
module io.inverno.example.app {
    ...
    requires io.inverno.mod.irt;
    ...
}
```

And also declare that dependency in the build descriptor:

Using Maven:

```xml
<project>
    <dependencies>
        <dependency>
            <groupId>io.inverno.mod</groupId>
            <artifactId>inverno-irt</artifactId>
        </dependency>
    </dependencies>
</project>
```

Using Gradle:

```java
...
compile 'io.inverno.mod:inverno-irt:${VERSION_INVERNO_MODS}'
...
```

## Creates an .irt template

A template can be created along with other Java source files in the source directory of an Inverno module. At compile time, the Inverno reactive template compiler plugin will scan the module source folder for `.irt` files and compiles them to generate template set classes that can be used in your module to render data.

The following `Simple.irt` template set is a simple example containing one template that renders a `Message` object as String:

```plaintext
package io.inverno.example.app_irt.templates;

import io.inverno.example.app_irt.model.Message;

option modes = {"STRING"};
option charset = "utf-8";

(Message message) -> {The message is: {@message.message}}
```

```java
package io.inverno.example.app_irt.model;

public class Message {

    private final String message;

    private final boolean important;

    public Message(String message, boolean important) {
        this.message = message;
        this.important = important;
    }

    public String getMessage() {
        return message;
    }

    public boolean isImportant() {
        return important;
    }
}
```

As for any Java source file, the preceding template source must be created in the same package as the one it declares in a module source folder. The name of the template corresponds to the name of the file.

After compiling the module, a new Java class `Simple.java` should have been created in the generated source folder in package `io.inverno.example.app_irt.templates`.

A `Message` object can then be rendered as follows:

```java
CompletableFuture<String> rendered = Simple.string().render(new Message("Hello, world!"));
System.out.println(rendered.get()); // The message is: Hello, world!
```

## .irt syntax

### Package and imports

An `.irt` template always starts with the declaration of the Java package containing the template, followed by the list of imported Java types or static methods used within the template. This is exactly the same as any Java source file.

```plaintext
package io.inverno.example.app_irt.templates;

import io.inverno.example.app_irt.model.Message;
...
```

### Includes

Then you can specify external template sets to include in the template set using the `include` keyword. This allows to include templates from an external template set in a template set using the same precedence. For instance, in the following example, template set `io.inverno.example.app_irt.templates.Misc` is included in the template set which means that its templates can be applied in the including template.

```plaintext
include io.inverno.example.app_irt.templates.Misc;
```

> Note that this can lead to conflicts when two included templates defines a template using the same signature (same name and same input parameters), such conflict can be resolved by explicitly overriding the conflicting template in the including template set.

### Options

Rendering options are specified after that using the `option` keyword. You can for instance declare the charset to use for rendering which defaults to `utf-8` if not specified: 

```plaintext
option charset = "utf-8";
```

or the template rendering modes supported by the generated template set. There are five template rendering modes, you can choose to specify one or more modes depending on your needs:

- **STRING** to expose methods to render data in a `String`, this is the default behavior
- **BYTEBUF** to expose methods to render data in a `ByteBuf`
- **STREAM** to expose methods to render data in an `OutputStream`
- **PUBLISHER_STRING** to expose methods to render data in a `Publisher<String>`
- **PUBLISHER_BYTEBUF** to expose methods to render data in a `Publisher<ByteBuf>`

The last two modes are particularly suitable for reactive rendering.

```plaintext
option modes = {"STRING", "STREAM", "PUBLISHER_STRING"};
```

### Templates

Templates are specified last. A template is a function that defines how a particular input must be rendered, a template can have a name in which case it is referred as a named template. In a template set, there can't be two templates with the same signature (ie. defining the same input parameters) unless they have different names.

A template is declared as follows:

```plaintext
(Message message) -> {...}
```

A named template is declared as follows:

```plaintext
name(Message message) -> {...}
```

A template can be defined with zero or more parameters. No parameter templates can be useful to create static templates such as headers or footers, they are usually named:

```plaintext
header() -> {...}
```

The body of a template is a combination of static content and statements which define how the template input should be rendered. Template statements are specified within braces `{...}` which must be escaped within static content using `\`.

A template can also be specified without a body in order to create aliases or resolve conflicts.

For instance the following template defines alias `apple` for template `fruit` (assuming `Apple` is an instance of `Fruit`):

```plaintext
apple(Apple fruit) -> this::fruit

fruit(Fruit fruit) -> {...}
```

And the following template resolves a conflict induced by the inclusion of template set `Include1` and `Include2` which both defines template `conflicting` with the same input parameters:

```plaintext
...
include io.inverno.example.app_irt.templates.Include1;
include io.inverno.example.app_irt.templates.Include2;
...

conflicting(String input) -> Include1
```

### Static content

Static contents are specified directly in the template body and are rendered as is:

```plaintext
(...) -> {
This is a static content, braces: \{ and \} must be escaped.
}
```

### Comment

The syntax supports two kinds of comments which can be either outside or inside the body of a template.

Outside the body of a template, comments are regular Java comments:

```plaintext
/*
 * This a comment to explain that the following import is commented
 */
// import java.util.List; 
```

Inside the body of a template, comments are statements starting with `{%` and ending with `}`:

```plaintext
(Message message) -> {
Hello {% this is a comment} World.
}
```

### Value of

A value can be rendered directly in a synchronous way within a statement starting with `{@` and ending with `}` as follows:

```plaintext
(Message message) -> {
The message is: {@message.message}
}
```

In the preceding example, we used a syntactic sugar to navigate into the message object hierarchy and access the `message` properties but it is also possible to evaluate a raw Java expression specified between `(` and `)` to get the same result:

```plaintext
(Message message) -> {
The message is: {@(message.getMessage())}
}
```

It is then possible to evaluate any Java expression:

```plaintext
(Message message) -> {
The message is: {@(5+8)}
}
```

> Note that this can be dangerous when you the origin of a template set can't be trusted.

### If

An if statement can be used to render different contents based on one or more conditions. An if statement starts with `{@if` and ends with `}`, it contains one or more branches separated by `;` defining a condition and a corresponding body, a default branch with an empty condition can be specified last. Each condition is specified as a raw Java if expression between `(` and `)`:

```plaintext
(Message message, String lang) -> {
    {@if
        (lang.equals("fr")) -> {
            Le message est: {@message.message}
        };
        (lang.equals("de")) -> {
            Die Nachricht ist: {@message.message}
        };
        () -> {
            The message is: {@message.message}
        }
    }
}
```

### Apply template

Templates can be applied on data using an apply template statement starting with `{` and ending with `}`. The template to apply is selected among the ones available in the template set based on the type of data to render following Java's rules for function overloading. 

As for the value of statement, it is possible to use a syntactic sugar notation or a raw Java expression between `(` and `)` to select the data on which a template should be applied. A template set provides a default template for object which simply renders the `toString()` representation of the input. Considering previous examples, the content of a message object can then also be rendered as follows:

```plaintext
(Message message) -> {
The message is: {message.message}
}
```

Unlike the value of statement which renders data synchronously, applying a template can be an asynchronous operation depending on the type of data to render. Indeed when the data to render is an an array, an `Iterable`, a `Stream` or a `Publisher`, the template is applied on each element and in the case of a `Publisher` the operation is reactive, non-blocking and therefore asynchronous.

For instance, a list of messages can be rendered synchronously as follows:

```plaintext
(List<Message> messages) -> {
Messages are: 
{messages}
}

(Message message) -> {{@message.message}
}
```

resulting in:

```plaintext
Messages are:
message 1
message 2
message 3
message 4
message 5
...
```

Now if we consider a `Publisher`, a message is rendered to the output when it is emitted by the publisher following reactive principles.

As you can see the apply template statement is extremely powerful, it is used to render data based on their types which facilitates composition but it can also be used as a for loop statement to render a list of elements.

By default, an apply template statement will select the unnamed template within the template set matching the type of data to render, but it is also possible to select a named templates as follows:

```plaintext
(List<Message> messages) -> {
Messages are: 
{messages;bullet}
}

(Message message) -> {{@message.message}
}

bullet(Message message) -> {* {@message.message}
}
```

resulting in:

```plaintext
Messages are:
* message 1
* message 2
* message 3
* message 4
* message 5
...
```

Extra parameters can also be passed to a template in which case we have to explicitly specify the inputs:

```plaintext
(List<Message> messages) -> {
Messages are: 
{messages; message -> bullet(message, "-")}
}

bullet(Message message, String marker) -> {{@marker} {@message.message}
}
```

resulting in:

```plaintext
Messages are:
- message 1
- message 2
- message 3
- message 4
- message 5
...
```

It is also possible to specify guard expressions as raw Java expressions and choose to apply different templates based on certain conditions. For instance, let's say we want to render important messages in a specific way, we can do as follows:

```plaintext
(List<Message> messages) -> {
Messages are: 
{messages;(message) -> important(message) when (message.isImportant());(message)}
}

(Message message) -> {{@message.message}
}

important(Message message) -> {**{@message.message}**
}

```

In the previous example, the `important` template is applied when a message is important and the unnamed template is applied otherwise. Assuming message 3 is important, this will result in:

```plaintext
Messages are:
- message 1
- message 2
- **message 3**
- message 4
- message 5
...
```

The index of an item in a list is made available when selecting the target template. For instance, a numbered list of messages can be rendered as follows:

```plaintext
(List<Message> messages) -> {
Messages are: 
{messages;(index, message) -> (index, message)}
}

(long index, Message message) -> {{@index}. {@message.message}
}
```

resulting in:

```plaintext
Messages are:
0. message 1
1. message 2
2. message 3
3. message 4
4. message 5
...
```

A no-arg named template can be applied by omitting the data part in the statement:

```plaintext
(Message message) -> {
    {;header}
    The message is: {@message.message}
    {;footer}
}

header() -> {==== HEADER ====
}

footer() -> {==== FOOTER ====
}
```

resulting in:

```plaintext
==== HEADER ====
The message is: {@message.message}
==== FOOTER ====
```

## Pipes

A pipe can be used to transform data before they are rendered or before a template is applied, as a result they can be specified in value of and apply template statements. In practice, a pipe is a simple function that accepts a data and transform it into another data. Pipes can be chained to sequentially apply multiple transformations.

A pipe can be specified as a lambda expression and applied using a `|` in a value of or apply template statement as follows:

```plaintext
(Message message) -> {
The message is: {@message.message|((String content) -> content.toUpperCase())}
}
```

Lambdas are handy when there's a need for very specific pipes, however the recommended way to create pipes is to define them in Java as static methods returning the `Pipe` implementation in order to keep the template readable. Above pipe can be defined in a Java class as follows:

```java
package io.inverno.example.app_irt.pipes; 

import io.inverno.mod.irt.Pipe;

public final class SamplePipes {

    public static Pipe<String, String> uppercase() {
        return String::toUpperCase;
    }
}
```

We can then statically import that class in the template set and simplify above example:


```plaintext
import static io.inverno.example.app_irt.pipes.SamplePipes.*;

(Message message) -> {
The message is: {@message.message|uppercase}
}
```

Several built-in pipes are provided in the module in the `Pipes`, `StreamPipes` and `PublisherPipes` classes. The `Pipes` class provides pipes used to tranform simple data object before rendering such as strings, dates and numbers. The `StreamPipes` and `PublisherPipes` provide pipes used to transformed streams and publishers typically in an apply template statement.

For instance the following example sort a list of items and map them to their datetime before applying templates:

```plaintext
import static io.inverno.mod.irt.Pipes.*;
import static io.inverno.mod.irt.PublisherPipes.*;

import java.time.format.DateTimeFormatter;

(Publisher<Item> items) -> {
    {items|sort|map(Item::getDateTime)}
}

(ZonedDateTime datetime) -> {
    {@datetime|dateTime(DateTimeFormatter.ISO_DATE_TIME)}
}
```

## Modes

Template set classes are generated by the Inverno reactive template compiler plugin. Depending on the modes specified in the template set options, the resulting class will expose different `render()` methods with different outputs.

### STRING

The **STRING** mode is the default resulting in the generation of `render()` methods that return a `CompletableFuture<String>` which completes once the input data has been fully rendered into the resulting String. For instance, assuming we have created a `Simple.irt` template set containing a template to render `Message` object, we can render a `Message` to a String as follows:

```java
String result = Simple.string().render(new Message("some important message", true)).get();
```

The rendering process start as soon as the `render()` method is invoked, the `get()` operation on the resulting `CompletableFuture` waits until the message has been fully rendered. In this particular example, the whole process is synchronous since the input data is available from the start but keep in mind that this might not always be the case especially when `Publisher` objects are rendered in the process.

### BYTEBUF

The **BYTEBUF** has a similar behavior except that data are rendered in a **ByteBuf**:

```java
ByteBuf result = Simple.bytebuf().render(new Message("some important message", true)).get();
```

It is possible to provide the `ByteBuf` instance into which data should be rendered by defining a factory:

```java
ByteBuf result = Simple.bytebuf(() -> Unpooled.unreleasableBuffer(Unpooled.buffer())).render(new Message("some important message", true)).get();
```

This can be useful to optimize memory as it allows to reuse `ByteBuf` instances or specify direct or pooled `ByteBuf`.

### STREAM

The **STREAM** mode is used to render data in an `OutputStream`:

```java
ByteArrayOutputStream result = Simple.stream(() -> new ByteArrayOutputStream()).render(new Message("some important message", true)).get();
```

### PUBLISHER_*

Finally the **PUBLISHER_STRING** and **PUBLISHER_BYTEBUF** modes are used to generate fully reactive rendering methods which return `Publisher<String>` and `Publisher<ByteBuf>` respectively. Unlike previous modes, the rendering process starts when a subscription is made on the returned `Publisher` which can emits partial rendering result whenever a partial data is rendered.

```java
String result = Flux.from(Simple.publisherString().render(new Message("some important message", true))).collect(Collectors.joining()).block();
```

If you consider small data set and require very high performance, you should prefer non-reactive modes. If your concern is more about resources, considering a large amount of data that you do not want to load into memory at once or progressive rendering you should prefer reactive modes which might have a slight decrease in performance.
