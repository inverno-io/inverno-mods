options {  JAVA_TEMPLATE_TYPE = "modern";  JDK_VERSION = "9";  LOOKAHEAD = 1;  CHOICE_AMBIGUITY_CHECK = 2;  OTHER_AMBIGUITY_CHECK = 1;  STATIC = false;  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;  ERROR_REPORTING = true;  JAVA_UNICODE_ESCAPE = false;  UNICODE_INPUT = false;  IGNORE_CASE = false;  USER_TOKEN_MANAGER = false;  USER_CHAR_STREAM = false;  BUILD_PARSER = true;  BUILD_TOKEN_MANAGER = true;  SANITY_CHECK = true;  FORCE_LA_CHECK = false;  TOKEN_FACTORY = "IrtToken";}PARSER_BEGIN(IrtParser)package io.inverno.mod.irt.compiler.internal.parser;import java.util.List;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;import java.util.stream.Stream;import java.util.stream.Collectors;import javax.lang.model.element.TypeElement;import javax.lang.model.type.TypeKind;import javax.lang.model.type.TypeMirror;import javax.lang.model.type.DeclaredType;import io.inverno.mod.irt.compiler.internal.*;import io.inverno.mod.irt.compiler.spi.*;public class IrtParser{	private IrtTypeResolver typeResolver;  	private String extractValue(Token beginToken, Token endToken, boolean endInclusive) {		Token previousToken = beginToken;		Token currentToken = beginToken;		String value = "";		while( (currentToken = currentToken.next) != null) {		  	if(currentToken != endToken || endInclusive) {				if(previousToken != beginToken && (previousToken.endLine < currentToken.beginLine || previousToken.endColumn < currentToken.beginColumn - 1) ) {					value += " ";				}				value += currentToken.image;				previousToken = currentToken;			}			if(currentToken == endToken) {				break;			}		}	    return value;   }	public void setTypeResolver(IrtTypeResolver typeResolver) {		this.typeResolver = typeResolver;	}   /**    * Class to hold modifiers.    */   static public final class ModifierSet   {     /* Definitions of the bits in the modifiers field.  */     public static final int PUBLIC = 0x0001;     public static final int PROTECTED = 0x0002;     public static final int PRIVATE = 0x0004;     public static final int ABSTRACT = 0x0008;     public static final int STATIC = 0x0010;     public static final int FINAL = 0x0020;     public static final int SYNCHRONIZED = 0x0040;     public static final int NATIVE = 0x0080;     public static final int TRANSIENT = 0x0100;     public static final int VOLATILE = 0x0200;     public static final int STRICTFP = 0x1000;     /** A set of accessors that indicate whether the specified modifier         is in the set. */     public boolean isPublic(int modifiers)     {       return (modifiers & PUBLIC) != 0;     }     public boolean isProtected(int modifiers)     {       return (modifiers & PROTECTED) != 0;     }     public boolean isPrivate(int modifiers)     {       return (modifiers & PRIVATE) != 0;     }     public boolean isStatic(int modifiers)     {       return (modifiers & STATIC) != 0;     }     public boolean isAbstract(int modifiers)     {       return (modifiers & ABSTRACT) != 0;     }     public boolean isFinal(int modifiers)     {       return (modifiers & FINAL) != 0;     }     public boolean isNative(int modifiers)     {       return (modifiers & NATIVE) != 0;     }     public boolean isStrictfp(int modifiers)     {       return (modifiers & STRICTFP) != 0;     }     public boolean isSynchronized(int modifiers)     {       return (modifiers & SYNCHRONIZED) != 0;     }     public boolean isTransient(int modifiers)      {       return (modifiers & TRANSIENT) != 0;     }     public boolean isVolatile(int modifiers)     {       return (modifiers & VOLATILE) != 0;     }     /**      * Removes the given modifier.      */     static int removeModifier(int modifiers, int mod)     {        return modifiers & ~mod;     }   }}PARSER_END(IrtParser)/* WHITE SPACE */SKIP :{  " "| "\t"| "\n"| "\r"| "\f"}/* COMMENTS */MORE :{  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT|  "/*" : IN_MULTI_LINE_COMMENT}SPECIAL_TOKEN :{  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>}<IN_FORMAL_COMMENT>SPECIAL_TOKEN :{  <FORMAL_COMMENT: "*/" > : DEFAULT}<IN_MULTI_LINE_COMMENT>SPECIAL_TOKEN :{  <MULTI_LINE_COMMENT: "*/" > : DEFAULT}<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>MORE :{  < ~[] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  < ABSTRACT: "abstract" >| < ASSERT: "assert" >| < BOOLEAN: "boolean" >| < BREAK: "break" >| < BYTE: "byte" >| < CASE: "case" >| < CATCH: "catch" >| < CHAR: "char" >| < CLASS: "class" >| < CONST: "const" >| < CONTINUE: "continue" >| < _DEFAULT: "default" >| < DO: "do" >| < DOUBLE: "double" >| < ELSE: "else" >| < ENUM: "enum" >| < EXTENDS: "extends" >| < FALSE: "false" >| < FINAL: "final" >| < FINALLY: "finally" >| < FLOAT: "float" >| < FOR: "for" >| < GOTO: "goto" >| < IF: "if" >| < IMPLEMENTS: "implements" >| < IMPORT: "import" >| < INSTANCEOF: "instanceof" >| < INT: "int" >| < INTERFACE: "interface" >| < LONG: "long" >| < NATIVE: "native" >| < NEW: "new" >| < NULL: "null" >| < PACKAGE: "package">| < PRIVATE: "private" >| < PROTECTED: "protected" >| < PUBLIC: "public" >| < RETURN: "return" >| < SHORT: "short" >| < STATIC: "static" >| < STRICTFP: "strictfp" >| < SUPER: "super" >| < SWITCH: "switch" >| < SYNCHRONIZED: "synchronized" >| < THIS: "this" >| < THROW: "throw" >| < THROWS: "throws" >| < TRANSIENT: "transient" >| < TRUE: "true" >| < TRY: "try" >| < VOID: "void" >| < VOLATILE: "volatile" >| < WHILE: "while" >| < INCLUDE: "include" >| < OPTION: "option" >| < WHEN: "when" >}/* LITERALS */TOKEN :{  < INTEGER_LITERAL:        <DECIMAL_LITERAL> (["l","L"])?      | <HEX_LITERAL> (["l","L"])?      | <OCTAL_LITERAL> (["l","L"])?  >|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >|  < #OCTAL_LITERAL: "0" (["0"-"7"])* >|  < FLOATING_POINT_LITERAL:        <DECIMAL_FLOATING_POINT_LITERAL>      | <HEXADECIMAL_FLOATING_POINT_LITERAL>  >|  < #DECIMAL_FLOATING_POINT_LITERAL:        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]  >|  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >|  < #HEXADECIMAL_FLOATING_POINT_LITERAL:        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?  >|  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >|  < CHARACTER_LITERAL:      "'"      (   (~["'","\\","\n","\r"])        | ("\\"            ( ["n","t","b","r","f","\\","'","\""]            | ["0"-"7"] ( ["0"-"7"] )?            | ["0"-"3"] ["0"-"7"] ["0"-"7"]            )          )      )      "'"  >|  < STRING_LITERAL:      "\""      (   (~["\"","\\","\n","\r"])        | ("\\"            ( ["n","t","b","r","f","\\","'","\""]            | ["0"-"7"] ( ["0"-"7"] )?            | ["0"-"3"] ["0"-"7"] ["0"-"7"]            )          )      )*      "\""  >}/* IDENTIFIERS */TOKEN :{  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >|  < #LETTER:      [  // all chars for which Character.isIdentifierStart is true         "$",         "A"-"Z",         "_",         "a"-"z",         "\u00a2"-"\u00a5",         "\u00aa",         "\u00b5",         "\u00ba",         "\u00c0"-"\u00d6",         "\u00d8"-"\u00f6",         "\u00f8"-"\u021f",         "\u0222"-"\u0233",         "\u0250"-"\u02ad",         "\u02b0"-"\u02b8",         "\u02bb"-"\u02c1",         "\u02d0"-"\u02d1",         "\u02e0"-"\u02e4",         "\u02ee",         "\u037a",         "\u0386",         "\u0388"-"\u038a",         "\u038c",         "\u038e"-"\u03a1",         "\u03a3"-"\u03ce",         "\u03d0"-"\u03d7",         "\u03da"-"\u03f3",         "\u0400"-"\u0481",         "\u048c"-"\u04c4",         "\u04c7"-"\u04c8",         "\u04cb"-"\u04cc",         "\u04d0"-"\u04f5",         "\u04f8"-"\u04f9",         "\u0531"-"\u0556",         "\u0559",         "\u0561"-"\u0587",         "\u05d0"-"\u05ea",         "\u05f0"-"\u05f2",         "\u0621"-"\u063a",         "\u0640"-"\u064a",         "\u0671"-"\u06d3",         "\u06d5",         "\u06e5"-"\u06e6",         "\u06fa"-"\u06fc",         "\u0710",         "\u0712"-"\u072c",         "\u0780"-"\u07a5",         "\u0905"-"\u0939",         "\u093d",         "\u0950",         "\u0958"-"\u0961",         "\u0985"-"\u098c",         "\u098f"-"\u0990",         "\u0993"-"\u09a8",         "\u09aa"-"\u09b0",         "\u09b2",         "\u09b6"-"\u09b9",         "\u09dc"-"\u09dd",         "\u09df"-"\u09e1",         "\u09f0"-"\u09f3",         "\u0a05"-"\u0a0a",         "\u0a0f"-"\u0a10",         "\u0a13"-"\u0a28",         "\u0a2a"-"\u0a30",         "\u0a32"-"\u0a33",         "\u0a35"-"\u0a36",         "\u0a38"-"\u0a39",         "\u0a59"-"\u0a5c",         "\u0a5e",         "\u0a72"-"\u0a74",         "\u0a85"-"\u0a8b",         "\u0a8d",         "\u0a8f"-"\u0a91",         "\u0a93"-"\u0aa8",         "\u0aaa"-"\u0ab0",         "\u0ab2"-"\u0ab3",         "\u0ab5"-"\u0ab9",         "\u0abd",         "\u0ad0",         "\u0ae0",         "\u0b05"-"\u0b0c",         "\u0b0f"-"\u0b10",         "\u0b13"-"\u0b28",         "\u0b2a"-"\u0b30",         "\u0b32"-"\u0b33",         "\u0b36"-"\u0b39",         "\u0b3d",         "\u0b5c"-"\u0b5d",         "\u0b5f"-"\u0b61",         "\u0b85"-"\u0b8a",         "\u0b8e"-"\u0b90",         "\u0b92"-"\u0b95",         "\u0b99"-"\u0b9a",         "\u0b9c",         "\u0b9e"-"\u0b9f",         "\u0ba3"-"\u0ba4",         "\u0ba8"-"\u0baa",         "\u0bae"-"\u0bb5",         "\u0bb7"-"\u0bb9",         "\u0c05"-"\u0c0c",         "\u0c0e"-"\u0c10",         "\u0c12"-"\u0c28",         "\u0c2a"-"\u0c33",         "\u0c35"-"\u0c39",         "\u0c60"-"\u0c61",         "\u0c85"-"\u0c8c",         "\u0c8e"-"\u0c90",         "\u0c92"-"\u0ca8",         "\u0caa"-"\u0cb3",         "\u0cb5"-"\u0cb9",         "\u0cde",         "\u0ce0"-"\u0ce1",         "\u0d05"-"\u0d0c",         "\u0d0e"-"\u0d10",         "\u0d12"-"\u0d28",         "\u0d2a"-"\u0d39",         "\u0d60"-"\u0d61",         "\u0d85"-"\u0d96",         "\u0d9a"-"\u0db1",         "\u0db3"-"\u0dbb",         "\u0dbd",         "\u0dc0"-"\u0dc6",         "\u0e01"-"\u0e30",         "\u0e32"-"\u0e33",         "\u0e3f"-"\u0e46",         "\u0e81"-"\u0e82",         "\u0e84",         "\u0e87"-"\u0e88",         "\u0e8a",         "\u0e8d",         "\u0e94"-"\u0e97",         "\u0e99"-"\u0e9f",         "\u0ea1"-"\u0ea3",         "\u0ea5",         "\u0ea7",         "\u0eaa"-"\u0eab",         "\u0ead"-"\u0eb0",         "\u0eb2"-"\u0eb3",         "\u0ebd",         "\u0ec0"-"\u0ec4",         "\u0ec6",         "\u0edc"-"\u0edd",         "\u0f00",         "\u0f40"-"\u0f47",         "\u0f49"-"\u0f6a",         "\u0f88"-"\u0f8b",         "\u1000"-"\u1021",         "\u1023"-"\u1027",         "\u1029"-"\u102a",         "\u1050"-"\u1055",         "\u10a0"-"\u10c5",         "\u10d0"-"\u10f6",         "\u1100"-"\u1159",         "\u115f"-"\u11a2",         "\u11a8"-"\u11f9",         "\u1200"-"\u1206",         "\u1208"-"\u1246",         "\u1248",         "\u124a"-"\u124d",         "\u1250"-"\u1256",         "\u1258",         "\u125a"-"\u125d",         "\u1260"-"\u1286",         "\u1288",         "\u128a"-"\u128d",         "\u1290"-"\u12ae",         "\u12b0",         "\u12b2"-"\u12b5",         "\u12b8"-"\u12be",         "\u12c0",         "\u12c2"-"\u12c5",         "\u12c8"-"\u12ce",         "\u12d0"-"\u12d6",         "\u12d8"-"\u12ee",         "\u12f0"-"\u130e",         "\u1310",         "\u1312"-"\u1315",         "\u1318"-"\u131e",         "\u1320"-"\u1346",         "\u1348"-"\u135a",         "\u13a0"-"\u13f4",         "\u1401"-"\u166c",         "\u166f"-"\u1676",         "\u1681"-"\u169a",         "\u16a0"-"\u16ea",         "\u1780"-"\u17b3",         "\u17db",         "\u1820"-"\u1877",         "\u1880"-"\u18a8",         "\u1e00"-"\u1e9b",         "\u1ea0"-"\u1ef9",         "\u1f00"-"\u1f15",         "\u1f18"-"\u1f1d",         "\u1f20"-"\u1f45",         "\u1f48"-"\u1f4d",         "\u1f50"-"\u1f57",         "\u1f59",         "\u1f5b",         "\u1f5d",         "\u1f5f"-"\u1f7d",         "\u1f80"-"\u1fb4",         "\u1fb6"-"\u1fbc",         "\u1fbe",         "\u1fc2"-"\u1fc4",         "\u1fc6"-"\u1fcc",         "\u1fd0"-"\u1fd3",         "\u1fd6"-"\u1fdb",         "\u1fe0"-"\u1fec",         "\u1ff2"-"\u1ff4",         "\u1ff6"-"\u1ffc",         "\u203f"-"\u2040",         "\u207f",         "\u20a0"-"\u20af",         "\u2102",         "\u2107",         "\u210a"-"\u2113",         "\u2115",         "\u2119"-"\u211d",         "\u2124",         "\u2126",         "\u2128",         "\u212a"-"\u212d",         "\u212f"-"\u2131",         "\u2133"-"\u2139",         "\u2160"-"\u2183",         "\u3005"-"\u3007",         "\u3021"-"\u3029",         "\u3031"-"\u3035",         "\u3038"-"\u303a",         "\u3041"-"\u3094",         "\u309d"-"\u309e",         "\u30a1"-"\u30fe",         "\u3105"-"\u312c",         "\u3131"-"\u318e",         "\u31a0"-"\u31b7",         "\u3400"-"\u4db5",         "\u4e00"-"\u9fa5",         "\ua000"-"\ua48c",         "\uac00"-"\ud7a3",         "\uf900"-"\ufa2d",         "\ufb00"-"\ufb06",         "\ufb13"-"\ufb17",         "\ufb1d",         "\ufb1f"-"\ufb28",         "\ufb2a"-"\ufb36",         "\ufb38"-"\ufb3c",         "\ufb3e",         "\ufb40"-"\ufb41",         "\ufb43"-"\ufb44",         "\ufb46"-"\ufbb1",         "\ufbd3"-"\ufd3d",         "\ufd50"-"\ufd8f",         "\ufd92"-"\ufdc7",         "\ufdf0"-"\ufdfb",         "\ufe33"-"\ufe34",         "\ufe4d"-"\ufe4f",         "\ufe69",         "\ufe70"-"\ufe72",         "\ufe74",         "\ufe76"-"\ufefc",         "\uff04",         "\uff21"-"\uff3a",         "\uff3f",         "\uff41"-"\uff5a",         "\uff65"-"\uffbe",         "\uffc2"-"\uffc7",         "\uffca"-"\uffcf",         "\uffd2"-"\uffd7",         "\uffda"-"\uffdc",         "\uffe0"-"\uffe1",         "\uffe5"-"\uffe6"      ]  >|  < #PART_LETTER:      [  // all chars for which Character.isIdentifierPart is true         "\u0000"-"\u0008",         "\u000e"-"\u001b",         "$",         "0"-"9",         "A"-"Z",         "_",         "a"-"z",         "\u007f"-"\u009f",         "\u00a2"-"\u00a5",         "\u00aa",         "\u00b5",         "\u00ba",         "\u00c0"-"\u00d6",         "\u00d8"-"\u00f6",         "\u00f8"-"\u021f",         "\u0222"-"\u0233",         "\u0250"-"\u02ad",         "\u02b0"-"\u02b8",         "\u02bb"-"\u02c1",         "\u02d0"-"\u02d1",         "\u02e0"-"\u02e4",         "\u02ee",         "\u0300"-"\u034e",         "\u0360"-"\u0362",         "\u037a",         "\u0386",         "\u0388"-"\u038a",         "\u038c",         "\u038e"-"\u03a1",         "\u03a3"-"\u03ce",         "\u03d0"-"\u03d7",         "\u03da"-"\u03f3",         "\u0400"-"\u0481",         "\u0483"-"\u0486",         "\u048c"-"\u04c4",         "\u04c7"-"\u04c8",         "\u04cb"-"\u04cc",         "\u04d0"-"\u04f5",         "\u04f8"-"\u04f9",         "\u0531"-"\u0556",         "\u0559",         "\u0561"-"\u0587",         "\u0591"-"\u05a1",         "\u05a3"-"\u05b9",         "\u05bb"-"\u05bd",         "\u05bf",         "\u05c1"-"\u05c2",         "\u05c4",         "\u05d0"-"\u05ea",         "\u05f0"-"\u05f2",         "\u0621"-"\u063a",         "\u0640"-"\u0655",         "\u0660"-"\u0669",         "\u0670"-"\u06d3",         "\u06d5"-"\u06dc",         "\u06df"-"\u06e8",         "\u06ea"-"\u06ed",         "\u06f0"-"\u06fc",         "\u070f"-"\u072c",         "\u0730"-"\u074a",         "\u0780"-"\u07b0",         "\u0901"-"\u0903",         "\u0905"-"\u0939",         "\u093c"-"\u094d",         "\u0950"-"\u0954",         "\u0958"-"\u0963",         "\u0966"-"\u096f",         "\u0981"-"\u0983",         "\u0985"-"\u098c",         "\u098f"-"\u0990",         "\u0993"-"\u09a8",         "\u09aa"-"\u09b0",         "\u09b2",         "\u09b6"-"\u09b9",         "\u09bc",         "\u09be"-"\u09c4",         "\u09c7"-"\u09c8",         "\u09cb"-"\u09cd",         "\u09d7",         "\u09dc"-"\u09dd",         "\u09df"-"\u09e3",         "\u09e6"-"\u09f3",         "\u0a02",         "\u0a05"-"\u0a0a",         "\u0a0f"-"\u0a10",         "\u0a13"-"\u0a28",         "\u0a2a"-"\u0a30",         "\u0a32"-"\u0a33",         "\u0a35"-"\u0a36",         "\u0a38"-"\u0a39",         "\u0a3c",         "\u0a3e"-"\u0a42",         "\u0a47"-"\u0a48",         "\u0a4b"-"\u0a4d",         "\u0a59"-"\u0a5c",         "\u0a5e",         "\u0a66"-"\u0a74",         "\u0a81"-"\u0a83",         "\u0a85"-"\u0a8b",         "\u0a8d",         "\u0a8f"-"\u0a91",         "\u0a93"-"\u0aa8",         "\u0aaa"-"\u0ab0",         "\u0ab2"-"\u0ab3",         "\u0ab5"-"\u0ab9",         "\u0abc"-"\u0ac5",         "\u0ac7"-"\u0ac9",         "\u0acb"-"\u0acd",         "\u0ad0",         "\u0ae0",         "\u0ae6"-"\u0aef",         "\u0b01"-"\u0b03",         "\u0b05"-"\u0b0c",         "\u0b0f"-"\u0b10",         "\u0b13"-"\u0b28",         "\u0b2a"-"\u0b30",         "\u0b32"-"\u0b33",         "\u0b36"-"\u0b39",         "\u0b3c"-"\u0b43",         "\u0b47"-"\u0b48",         "\u0b4b"-"\u0b4d",         "\u0b56"-"\u0b57",         "\u0b5c"-"\u0b5d",         "\u0b5f"-"\u0b61",         "\u0b66"-"\u0b6f",         "\u0b82"-"\u0b83",         "\u0b85"-"\u0b8a",         "\u0b8e"-"\u0b90",         "\u0b92"-"\u0b95",         "\u0b99"-"\u0b9a",         "\u0b9c",         "\u0b9e"-"\u0b9f",         "\u0ba3"-"\u0ba4",         "\u0ba8"-"\u0baa",         "\u0bae"-"\u0bb5",         "\u0bb7"-"\u0bb9",         "\u0bbe"-"\u0bc2",         "\u0bc6"-"\u0bc8",         "\u0bca"-"\u0bcd",         "\u0bd7",         "\u0be7"-"\u0bef",         "\u0c01"-"\u0c03",         "\u0c05"-"\u0c0c",         "\u0c0e"-"\u0c10",         "\u0c12"-"\u0c28",         "\u0c2a"-"\u0c33",         "\u0c35"-"\u0c39",         "\u0c3e"-"\u0c44",         "\u0c46"-"\u0c48",         "\u0c4a"-"\u0c4d",         "\u0c55"-"\u0c56",         "\u0c60"-"\u0c61",         "\u0c66"-"\u0c6f",         "\u0c82"-"\u0c83",         "\u0c85"-"\u0c8c",         "\u0c8e"-"\u0c90",         "\u0c92"-"\u0ca8",         "\u0caa"-"\u0cb3",         "\u0cb5"-"\u0cb9",         "\u0cbe"-"\u0cc4",         "\u0cc6"-"\u0cc8",         "\u0cca"-"\u0ccd",         "\u0cd5"-"\u0cd6",         "\u0cde",         "\u0ce0"-"\u0ce1",         "\u0ce6"-"\u0cef",         "\u0d02"-"\u0d03",         "\u0d05"-"\u0d0c",         "\u0d0e"-"\u0d10",         "\u0d12"-"\u0d28",         "\u0d2a"-"\u0d39",         "\u0d3e"-"\u0d43",         "\u0d46"-"\u0d48",         "\u0d4a"-"\u0d4d",         "\u0d57",         "\u0d60"-"\u0d61",         "\u0d66"-"\u0d6f",         "\u0d82"-"\u0d83",         "\u0d85"-"\u0d96",         "\u0d9a"-"\u0db1",         "\u0db3"-"\u0dbb",         "\u0dbd",         "\u0dc0"-"\u0dc6",         "\u0dca",         "\u0dcf"-"\u0dd4",         "\u0dd6",         "\u0dd8"-"\u0ddf",         "\u0df2"-"\u0df3",         "\u0e01"-"\u0e3a",         "\u0e3f"-"\u0e4e",         "\u0e50"-"\u0e59",         "\u0e81"-"\u0e82",         "\u0e84",         "\u0e87"-"\u0e88",         "\u0e8a",         "\u0e8d",         "\u0e94"-"\u0e97",         "\u0e99"-"\u0e9f",         "\u0ea1"-"\u0ea3",         "\u0ea5",         "\u0ea7",         "\u0eaa"-"\u0eab",         "\u0ead"-"\u0eb9",         "\u0ebb"-"\u0ebd",         "\u0ec0"-"\u0ec4",         "\u0ec6",         "\u0ec8"-"\u0ecd",         "\u0ed0"-"\u0ed9",         "\u0edc"-"\u0edd",         "\u0f00",         "\u0f18"-"\u0f19",         "\u0f20"-"\u0f29",         "\u0f35",         "\u0f37",         "\u0f39",         "\u0f3e"-"\u0f47",         "\u0f49"-"\u0f6a",         "\u0f71"-"\u0f84",         "\u0f86"-"\u0f8b",         "\u0f90"-"\u0f97",         "\u0f99"-"\u0fbc",         "\u0fc6",         "\u1000"-"\u1021",         "\u1023"-"\u1027",         "\u1029"-"\u102a",         "\u102c"-"\u1032",         "\u1036"-"\u1039",         "\u1040"-"\u1049",         "\u1050"-"\u1059",         "\u10a0"-"\u10c5",         "\u10d0"-"\u10f6",         "\u1100"-"\u1159",         "\u115f"-"\u11a2",         "\u11a8"-"\u11f9",         "\u1200"-"\u1206",         "\u1208"-"\u1246",         "\u1248",         "\u124a"-"\u124d",         "\u1250"-"\u1256",         "\u1258",         "\u125a"-"\u125d",         "\u1260"-"\u1286",         "\u1288",         "\u128a"-"\u128d",         "\u1290"-"\u12ae",         "\u12b0",         "\u12b2"-"\u12b5",         "\u12b8"-"\u12be",         "\u12c0",         "\u12c2"-"\u12c5",         "\u12c8"-"\u12ce",         "\u12d0"-"\u12d6",         "\u12d8"-"\u12ee",         "\u12f0"-"\u130e",         "\u1310",         "\u1312"-"\u1315",         "\u1318"-"\u131e",         "\u1320"-"\u1346",         "\u1348"-"\u135a",         "\u1369"-"\u1371",         "\u13a0"-"\u13f4",         "\u1401"-"\u166c",         "\u166f"-"\u1676",         "\u1681"-"\u169a",         "\u16a0"-"\u16ea",         "\u1780"-"\u17d3",         "\u17db",         "\u17e0"-"\u17e9",         "\u180b"-"\u180e",         "\u1810"-"\u1819",         "\u1820"-"\u1877",         "\u1880"-"\u18a9",         "\u1e00"-"\u1e9b",         "\u1ea0"-"\u1ef9",         "\u1f00"-"\u1f15",         "\u1f18"-"\u1f1d",         "\u1f20"-"\u1f45",         "\u1f48"-"\u1f4d",         "\u1f50"-"\u1f57",         "\u1f59",         "\u1f5b",         "\u1f5d",         "\u1f5f"-"\u1f7d",         "\u1f80"-"\u1fb4",         "\u1fb6"-"\u1fbc",         "\u1fbe",         "\u1fc2"-"\u1fc4",         "\u1fc6"-"\u1fcc",         "\u1fd0"-"\u1fd3",         "\u1fd6"-"\u1fdb",         "\u1fe0"-"\u1fec",         "\u1ff2"-"\u1ff4",         "\u1ff6"-"\u1ffc",         "\u200c"-"\u200f",         "\u202a"-"\u202e",         "\u203f"-"\u2040",         "\u206a"-"\u206f",         "\u207f",         "\u20a0"-"\u20af",         "\u20d0"-"\u20dc",         "\u20e1",         "\u2102",         "\u2107",         "\u210a"-"\u2113",         "\u2115",         "\u2119"-"\u211d",         "\u2124",         "\u2126",         "\u2128",         "\u212a"-"\u212d",         "\u212f"-"\u2131",         "\u2133"-"\u2139",         "\u2160"-"\u2183",         "\u3005"-"\u3007",         "\u3021"-"\u302f",         "\u3031"-"\u3035",         "\u3038"-"\u303a",         "\u3041"-"\u3094",         "\u3099"-"\u309a",         "\u309d"-"\u309e",         "\u30a1"-"\u30fe",         "\u3105"-"\u312c",         "\u3131"-"\u318e",         "\u31a0"-"\u31b7",         "\u3400"-"\u4db5",         "\u4e00"-"\u9fa5",         "\ua000"-"\ua48c",         "\uac00"-"\ud7a3",         "\uf900"-"\ufa2d",         "\ufb00"-"\ufb06",         "\ufb13"-"\ufb17",         "\ufb1d"-"\ufb28",         "\ufb2a"-"\ufb36",         "\ufb38"-"\ufb3c",         "\ufb3e",         "\ufb40"-"\ufb41",         "\ufb43"-"\ufb44",         "\ufb46"-"\ufbb1",         "\ufbd3"-"\ufd3d",         "\ufd50"-"\ufd8f",         "\ufd92"-"\ufdc7",         "\ufdf0"-"\ufdfb",         "\ufe20"-"\ufe23",         "\ufe33"-"\ufe34",         "\ufe4d"-"\ufe4f",         "\ufe69",         "\ufe70"-"\ufe72",         "\ufe74",         "\ufe76"-"\ufefc",         "\ufeff",         "\uff04",         "\uff10"-"\uff19",         "\uff21"-"\uff3a",         "\uff3f",         "\uff41"-"\uff5a",         "\uff65"-"\uffbe",         "\uffc2"-"\uffc7",         "\uffca"-"\uffcf",         "\uffd2"-"\uffd7",         "\uffda"-"\uffdc",         "\uffe0"-"\uffe1",         "\uffe5"-"\uffe6",         "\ufff9"-"\ufffb"      ]  >}/* SEPARATORS */TOKEN :{  < LPAREN: "(" >| < RPAREN: ")" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >| < DOT: "." >| < AT: "@" >}/* OPERATORS */TOKEN :{  < ASSIGN: "=" >| < LT: "<" >| < BANG: "!" >| < TILDE: "~" >| < HOOK: "?" >| < COLON: ":" >| < EQ: "==" >| < LE: "<=" >| < GE: ">=" >| < NE: "!=" >| < SC_OR: "||" >| < SC_AND: "&&" >| < INCR: "++" >| < DECR: "--" >| < PLUS: "+" >| < MINUS: "-" >| < STAR: "*" >| < SLASH: "/" >| < BIT_AND: "&" >| < BIT_OR: "|" >| < XOR: "^" >| < REM: "%" >| < LSHIFT: "<<" >| < PLUSASSIGN: "+=" >| < MINUSASSIGN: "-=" >| < STARASSIGN: "*=" >| < SLASHASSIGN: "/=" >| < ANDASSIGN: "&=" >| < ORASSIGN: "|=" >| < XORASSIGN: "^=" >| < REMASSIGN: "%=" >| < LSHIFTASSIGN: "<<=" >| < RSIGNEDSHIFTASSIGN: ">>=" >| < RUNSIGNEDSHIFTASSIGN: ">>>=" >| < ELLIPSIS: "..." >| < ARROW: "->" >}/* >'s need special attention due to generics syntax. */TOKEN :{  < RUNSIGNEDSHIFT: ">>>" >  {     matchedToken.kind = GT;     ((IrtToken)matchedToken).realKind = RUNSIGNEDSHIFT;     input_stream.backup(2);     matchedToken.image = ">";  }| < RSIGNEDSHIFT: ">>" >  {     matchedToken.kind = GT;     ((IrtToken)matchedToken).realKind = RSIGNEDSHIFT;     input_stream.backup(1);     matchedToken.image = ">";  }| < GT: ">" >}<IN_TEMPLATE_STATIC>TOKEN:{	< STATIC_LITERAL:		( ( ~[ "{", "}" ] )		| ( "\\" ( "{" | "}" ) )      )*	> : DEFAULT}TemplateSetInfo TemplateSet() :{	Token beginToken;	PackageInfo templatePackage = null;	ImportInfo currentImport;	List<ImportInfo> imports = new ArrayList<>();	IncludeInfo currentInclude;	List<IncludeInfo> includes = new ArrayList<>();	OptionInfo currentOption;	List<OptionInfo> options = new ArrayList<>();	TemplateInfo currentTemplate;	List<TemplateInfo> templates = new ArrayList<>();}{	{ beginToken = this.token; }	[ templatePackage = PackageDeclaration() ]	( currentImport = ImportDeclaration() { imports.add(currentImport); } )*	( currentInclude = IncludeDeclaration() { includes.add(currentInclude); } )*	( currentOption = OptionDeclaration() { options.add(currentOption); } )*	( currentTemplate = TemplateDeclaration() { templates.add(currentTemplate); })*	<EOF>	{		return new GenericTemplateSetInfo(new Range(beginToken, this.token), templatePackage, imports, includes, options, templates);	}}PackageInfo PackageDeclaration() :{	Token beginToken, endToken;	NameInfo name;}{	Modifiers() beginToken = "package" name = Name() endToken = ";"	{		this.typeResolver.setPackage(Arrays.asList(name.getParts()));		return new GenericPackageInfo(new Range(beginToken, endToken), name); 	}}ImportInfo ImportDeclaration() :{	Token beginToken, endToken;	NameInfo name;	boolean staticImport = false;}{	beginToken = "import" [ "static" { staticImport = true; } ] name = Name() [ "." "*" { name = new GenericNameInfo(((LocatableInfo)name).getRange().withEnd(this.token), Stream.concat(Arrays.stream(name.getParts()), Stream.of("*")).collect(Collectors.toList())); } ] endToken = ";"	{		this.typeResolver.addImport(Arrays.asList(name.getParts()));		return new GenericImportInfo(new Range(beginToken, endToken), name, staticImport); 	}}IncludeInfo IncludeDeclaration() :{	Token beginToken, endToken;	NameInfo name;}{	beginToken = "include" name = Name() endToken = ";"	{		return new GenericIncludeInfo(new Range(beginToken, endToken), name); 	}}OptionInfo OptionDeclaration() :{	Token beginToken, endToken, nameToken;	String name;	Object value;}{	beginToken = "option" nameToken = < IDENTIFIER > { name = nameToken.image; } "=" value = OptionValue() endToken = ";"	{		return new GenericOptionInfo(new Range(beginToken, endToken), name, value); 	}}Object OptionValue():{	Token token;	Object value = null;}{  (    LOOKAHEAD("{")    value = OptionValueList()  	|  	value = OptionValueLiteral()  )  {    return value;  }}Object OptionValueList():{	List<Object> values = new LinkedList<>();	Object currentValue;}{	"{" [ currentValue = OptionValueLiteral() { values.add(currentValue); } ( "," currentValue = OptionValueLiteral() { values.add(currentValue); } )* ] "}"	{		return values;	}}Object OptionValueLiteral():{	Token token;	Object value = null;}{  (      token = <INTEGER_LITERAL> { value = Integer.parseInt(token.image); }    |      token = <FLOATING_POINT_LITERAL> { value = Float.parseFloat(token.image); }    |      token = <CHARACTER_LITERAL> { value = token.image.charAt(0); }    |      token = <STRING_LITERAL> { value = token.image.substring(1, token.image.length()-1); }    |      ( token = "true" | token = "false" ) { value = Boolean.valueOf(token.image); }    |      NullLiteral()  )  {    return value;  }}TemplateInfo TemplateDeclaration():{	Token beginToken;	String name = null;	List<ParameterInfo> parameters;	List<StatementInfo> statements = null;	TemplateInfo.SelectInfo select = null;}{	{ beginToken = this.token; }	( name = TemplateName() )? parameters = TemplateFormalParameters() "->" ( LOOKAHEAD( "{" ) statements = TemplateBody() | select = TemplateSelect() )	{		return new GenericTemplateInfo(new Range(beginToken, this.token), name, parameters, statements, select);	}}String TemplateName():{}{	< IDENTIFIER >	{		return this.token.image;	}}List<ParameterInfo> TemplateFormalParameters():{	List<ParameterInfo> parameters = new ArrayList<>();	ParameterInfo currentParameter;}{  "(" [ currentParameter = TemplateFormalParameter() { parameters.add(currentParameter); } ( "," currentParameter = TemplateFormalParameter() { parameters.add(currentParameter); } )* ] ")"  {    return parameters;  }}ParameterInfo TemplateFormalParameter():{	Token beginToken;	String parameterName;	TypeMirror parameterType;}{  { beginToken = this.token; }  Modifiers() [ "final" | Annotation() ] parameterType = Type() [ "..." { parameterType = this.typeResolver.getTypeUtils().getArrayType(parameterType); } ] parameterName = TemplateTemplateFormalParameterId()  {	return new GenericParameterInfo(new Range(beginToken.next, this.token), parameterName, parameterType, this.extractValue(beginToken, this.token, true));  }}String TemplateTemplateFormalParameterId():{	Token idToken;}{	idToken = <IDENTIFIER> ( "[" "]" )*	{		return idToken.image;	}}TemplateInfo.SelectInfo TemplateSelect():{	Token beginToken;	NameInfo templateSetName = null;	String templateName = null;}{	{ beginToken = this.token; }	(		templateSetName = Name() [ "::" templateName = TemplateName() ]		|		"this" "::" templateName = TemplateName()	)	{		return new GenericTemplateInfo.GenericSelectInfo(new Range(beginToken.next, this.token), templateSetName, templateName);	}}List<StatementInfo> TemplateBody():{	List<StatementInfo> statements = new ArrayList<>();	StatementInfo currentStatement = null;}{	"{" { token_source.SwitchTo(IN_TEMPLATE_STATIC); }	(		currentStatement = TemplateStatic() { if(!((StaticContentInfo)currentStatement).getContent().isEmpty()) { statements.add(currentStatement); } }		|		currentStatement = TemplateStatement() { if(currentStatement != null) { statements.add(currentStatement); } }	)*	"}"	{		token_source.SwitchTo(DEFAULT);		return statements;	}}StaticContentInfo TemplateStatic():{}{	< STATIC_LITERAL >	{		return new GenericStaticContentInfo(new Range(this.token, this.token), this.token.image.replace("\\{", "{").replace("\\}", "}"));	}}StatementInfo TemplateStatement():{	StatementInfo statement = null;}{	(		LOOKAHEAD( "{%" )		statement = TemplateCommentStatement()		| 		LOOKAHEAD( "{" "@" "if" )		statement = TemplateIfStatement()		|		LOOKAHEAD( "{" "@" )		statement = TemplateValueOfStatement()		|		LOOKAHEAD( "{" )		statement = TemplateApplyStatement()	)	{		token_source.SwitchTo(IN_TEMPLATE_STATIC);		return statement;	}}CommentInfo TemplateCommentStatement():{	Token beginToken, endToken;	List<StatementInfo> statements;}{	beginToken = "{%"	statements = TemplateBody()	endToken = "}"	{		return new GenericCommentInfo(new Range(beginToken, endToken), statements);	}}IfInfo TemplateIfStatement():{	Token beginToken, endToken;	LinkedList<IfInfo.CaseInfo> cases = new LinkedList<>();}{	beginToken = "{" "@" "if" IfGuard(cases) endToken = "}"	{		return new GenericIfInfo(new Range(beginToken, endToken), cases);	}}void IfGuard(LinkedList<IfInfo.CaseInfo> cases):{	Token beginToken, expressionEndToken;	String expression;	List<StatementInfo> statements;}{	beginToken = "(" ConditionalExpression() expressionEndToken = ")" { expression = this.extractValue(beginToken, expressionEndToken, false); }  "->" statements = TemplateBody() [ ";" ( LOOKAHEAD(2) IfGuard(cases) | IfDefaultGuard(cases) ) ]	{		cases.addFirst(new GenericIfInfo.GenericCaseInfo(new Range(beginToken, this.token), expression, statements));	}}void IfDefaultGuard(LinkedList<IfInfo.CaseInfo> cases):{	Token beginToken;	List<StatementInfo> statements;}{	beginToken = "(" ")" "->" statements = TemplateBody()	{		cases.addFirst(new GenericIfInfo.GenericCaseInfo(new Range(beginToken, this.token), null, statements));	}}ValueInfo TemplateValueOfStatement():{	Token beginToken, endToken;	Token expressionBeginToken, expressionEndToken;	String expression = null;	NameInfo name = null;	List<PipeInfo> pipes = new ArrayList<>();	PipeInfo currentPipe;}{	beginToken= "{" "@"	(		expressionBeginToken = "(" ConditionalExpression() expressionEndToken = ")" { expression = this.extractValue(expressionBeginToken, expressionEndToken, false); }		|		name = Name()	)	( "|" currentPipe = ApplyPipe() { pipes.add(currentPipe); } )*	endToken = "}"	{		return new GenericValueInfo(new Range(beginToken, endToken), name, expression, pipes);	}}ApplyInfo TemplateApplyStatement():{	Token beginToken, endToken;	Token expressionBeginToken, expressionEndToken;	NameInfo name = null;	String expression = null;	ValueInfo value = null;	List<PipeInfo> pipes = new ArrayList<>();	PipeInfo currentPipe;	List<ApplyInfo.TargetInfo> targets = new ArrayList<>();	List<ApplyInfo.TargetParameterInfo> targetParameters = new ArrayList<>();	ApplyInfo.TargetInfo currentTarget;}{	beginToken = "{"	[		(			expressionBeginToken = "(" [ ConditionalExpression() ] expressionEndToken = ")" { expression = this.extractValue(expressionBeginToken, expressionEndToken, false); }			|			name = Name()		)		( "|" currentPipe = ApplyPipe() { pipes.add(currentPipe); } )*		{ value = new GenericValueInfo(new Range(beginToken.next, this.token), name, expression == null || expression.isEmpty() ? null : expression, pipes); }	]	[ ";" [ LOOKAHEAD(ApplyTargetParameters()) targetParameters = ApplyTargetParameters() ] currentTarget = ApplyTarget() { targets.add(currentTarget); } ( ";" currentTarget = ApplyTarget() { targets.add(currentTarget); } )* ]	endToken = "}"	{		if(value == null && !targetParameters.isEmpty()) {			throw new IrtCompilationException("Parameters can't be declared without a value", new Range(beginToken, endToken));		}		else { 			return new GenericApplyInfo(new Range(beginToken, endToken), value, targetParameters, targets);		}	} }List<ApplyInfo.TargetParameterInfo> ApplyTargetParameters():{	List<ApplyInfo.TargetParameterInfo> targetParameters = new LinkedList<>();	Token currentNameToken = null;	ParameterInfo currentParameter = null;}{  (      LOOKAHEAD( "(" FormalParameter() )      "(" currentParameter = TemplateFormalParameter() { targetParameters.add(new GenericApplyInfo.GenericTargetParameterInfo(((LocatableInfo)currentParameter).getRange(), null, currentParameter)); } ( "," currentParameter = TemplateFormalParameter() { targetParameters.add(new GenericApplyInfo.GenericTargetParameterInfo(((BaseInfo)currentParameter).getRange(), null, currentParameter)); } )* ")"    |      LOOKAHEAD("(" < IDENTIFIER > )      "(" currentNameToken = < IDENTIFIER > { targetParameters.add(new GenericApplyInfo.GenericTargetParameterInfo(new Range(currentNameToken, currentNameToken), currentNameToken.image, null)); } ( "," currentNameToken = < IDENTIFIER > { targetParameters.add(new GenericApplyInfo.GenericTargetParameterInfo(new Range(currentNameToken, currentNameToken), currentNameToken.image, null)); } )* ")"    |      currentNameToken = < IDENTIFIER > { targetParameters.add(new GenericApplyInfo.GenericTargetParameterInfo(new Range(currentNameToken, currentNameToken), currentNameToken.image, null)); }  )  "->"  {    return targetParameters;  }}PipeInfo ApplyPipe():{	Token beginToken, expressionEndToken;	String expression = null;	NameInfo name = null;	List<ApplyInfo.ArgumentInfo> arguments = null;}{	(	    { beginToken = this.token; arguments = List.of(); }		name = Name() [ arguments = ApplyArguments() ]		|		beginToken = "(" Expression() expressionEndToken = ")" { expression = this.extractValue(beginToken, expressionEndToken, false); }	)	{		return new GenericPipeInfo(new Range(name != null ? beginToken.next : beginToken, this.token), name, arguments, expression);	}}ApplyInfo.TargetInfo ApplyTarget():{	Token beginToken;	Token expressionBeginToken, expressionEndToken;	String templateName = null;	List<ApplyInfo.ArgumentInfo> arguments = List.of();	String expression = null;}{  { beginToken = this.token; }  (    templateName = TemplateName() [ arguments = ApplyArguments() ]    |    arguments = ApplyArguments()  )  [ "when" expressionBeginToken = "(" ConditionalExpression() expressionEndToken = ")" { expression = this.extractValue(expressionBeginToken, expressionEndToken, false); }]  {    return new GenericApplyInfo.GenericTargetInfo(new Range(beginToken.next, this.token), templateName, arguments, expression);  }}List<ApplyInfo.ArgumentInfo> ApplyArguments():{	List<ApplyInfo.ArgumentInfo> arguments = new ArrayList<>();	ApplyInfo.ArgumentInfo currentArgument;}{  "(" [ currentArgument = ApplyArgument() { arguments.add(currentArgument); } ( "," currentArgument = ApplyArgument() { arguments.add(currentArgument); } )* ] ")"  {	return arguments;  }}ApplyInfo.ArgumentInfo ApplyArgument():{	Token beginToken;}{	{ beginToken = this.token; }	Expression()	{		return new GenericApplyInfo.GenericArgumentInfo(new Range(beginToken, this.token), this.extractValue(beginToken, this.token, true));	}}/* Java "like" *//***************************************** * THE JAVA LANGUAGE GRAMMAR STARTS HERE * *****************************************//* * Program structuring syntax follows. *//*void CompilationUnit():{}{  [ LOOKAHEAD( ( Annotation() )* "package" ) PackageDeclaration() ]  ( ImportDeclaration() )*  ( TypeDeclaration() )+  ( < "\u001a" > )?  ( <STUFF_TO_IGNORE: ~[]> )?  <EOF>}void PackageDeclaration():{}{  Modifiers() "package" Name() ";"}void ImportDeclaration():{}{  "import" [ "static" ] Name() [ "." "*" ] ";"}*//* * Modifiers. We match all modifiers in a single rule to reduce the chances of * syntax errors for simple modifier mistakes. It will also enable us to give * better error messages. */int Modifiers():{   int modifiers = 0;}{ (  LOOKAHEAD(2)  (   "public" { modifiers |= ModifierSet.PUBLIC; }  |   "static" { modifiers |= ModifierSet.STATIC; }  |   "protected" { modifiers |= ModifierSet.PROTECTED; }  |   "private" { modifiers |= ModifierSet.PRIVATE; }  |   "final" { modifiers |= ModifierSet.FINAL; }  |   "abstract" { modifiers |= ModifierSet.ABSTRACT; }  |   "synchronized" { modifiers |= ModifierSet.SYNCHRONIZED; }  |   "native" { modifiers |= ModifierSet.NATIVE; }  |   "transient" { modifiers |= ModifierSet.TRANSIENT; }  |   "volatile" { modifiers |= ModifierSet.VOLATILE; }  |   "strictfp" { modifiers |= ModifierSet.STRICTFP; }  |   Annotation()  ) )* {    return modifiers; }}/* * Declaration syntax follows. */void TypeDeclaration():{   int modifiers;}{  ";"|  modifiers = Modifiers()  (     ClassOrInterfaceDeclaration(modifiers)   |     EnumDeclaration(modifiers)   |     AnnotationTypeDeclaration(modifiers)  )}void ClassOrInterfaceDeclaration(int modifiers):{   boolean isInterface = false;}{  ( "class" | "interface" { isInterface = true; } )  <IDENTIFIER>  [ TypeParameters() ]  [ ExtendsList(isInterface) ]  [ ImplementsList(isInterface) ]  ClassOrInterfaceBody(isInterface)}void ExtendsList(boolean isInterface):{   boolean extendsMoreThanOne = false;}{   "extends" ClassOrInterfaceType()   ( "," ClassOrInterfaceType() { extendsMoreThanOne = true; } )*   {      if (extendsMoreThanOne && !isInterface)         throw new ParseException("A class cannot extend more than one other class");   }}void ImplementsList(boolean isInterface):{}{   "implements" ClassOrInterfaceType()   ( "," ClassOrInterfaceType() )*   {      if (isInterface)         throw new ParseException("An interface cannot implement other interfaces");   }}void EnumDeclaration(int modifiers):{}{  "enum" <IDENTIFIER>  [ ImplementsList(false) ]  EnumBody()}void EnumBody():{}{   "{"   [ EnumConstant() ( LOOKAHEAD(2) "," EnumConstant() )* ]    [ "," ]   [ ";" ( ClassOrInterfaceBodyDeclaration(false) )* ]   "}"}void EnumConstant():{}{  Modifiers() <IDENTIFIER> [ Arguments() ] [ ClassOrInterfaceBody(false) ]}void TypeParameters():{}{   "<" TypeParameter() ( "," TypeParameter() )* ">"}void TypeParameter():{}{   <IDENTIFIER> [ TypeBound() ]}void TypeBound():{}{   "extends" ClassOrInterfaceType() ( "&" ClassOrInterfaceType() )*}void ClassOrInterfaceBody(boolean isInterface):{}{  "{" ( ClassOrInterfaceBodyDeclaration(isInterface) )* "}"}void ClassOrInterfaceBodyDeclaration(boolean isInterface):{   int modifiers;}{  LOOKAHEAD(2)  Initializer()  {     if (isInterface)        throw new ParseException("An interface cannot have initializers");  }|  modifiers = Modifiers() // Just get all the modifiers out of the way. If you want to do              // more checks, pass the modifiers down to the member  (      ClassOrInterfaceDeclaration(modifiers)    |      EnumDeclaration(modifiers)    |      LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" )      ConstructorDeclaration()    |      LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )      FieldDeclaration(modifiers)    |      MethodDeclaration(modifiers)    |      AnnotationTypeDeclaration(modifiers)  )|  ";"}void FieldDeclaration(int modifiers):{}{  // Modifiers are already matched in the caller  Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"}void VariableDeclarator():{}{  VariableDeclaratorId() [ "=" VariableInitializer() ]}void VariableDeclaratorId():{}{  <IDENTIFIER> ( "[" "]" )*}void VariableInitializer():{}{  ArrayInitializer()|  Expression()}void ArrayInitializer():{}{  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"}void MethodDeclaration(int modifiers):{}{  // Modifiers already matched in the caller!  [ TypeParameters() ]  ResultType()  MethodDeclarator() [ "throws" NameList() ]  ( Block() | ";" )}void MethodDeclarator():{}{  <IDENTIFIER> FormalParameters() ( "[" "]" )*}void FormalParameters():{}{  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"}void FormalParameter():{}{  // danson, added  //          [ "final" | Annotation() ]  // See Java Language Specification, 3rd Edition, section 8.4.1  Modifiers() [ "final" | Annotation() ] Type() [ "..." ] VariableDeclaratorId()}void LambdaParameters():{}{  FormalParameter() ( "," FormalParameter() )*}void InferredLambdaParameters():{}{  < IDENTIFIER > ( "," < IDENTIFIER > )*}void ConstructorDeclaration():{}{  [ TypeParameters() ]  // Modifiers matched in the caller  <IDENTIFIER> FormalParameters() [ "throws" NameList() ]  "{"    [ LOOKAHEAD(ExplicitConstructorInvocation())         ExplicitConstructorInvocation()    ]    ( BlockStatement() )*  "}"}void ExplicitConstructorInvocation():{}{  ( <IDENTIFIER> "." )* [ LOOKAHEAD(2) "this" "." ]  [ TypeArguments() ] ("this"|"super") Arguments() ";"}void Initializer():{}{  [ "static" ] Block()}/* * Type, name and expression syntax follows. */TypeMirror Type():{  TypeMirror type;}{  (    LOOKAHEAD(2) type = ReferenceType()    |	    type = PrimitiveType()  )  {    return type;  }}void AnnotatedType():{}{    Annotations() Type()}TypeMirror ReferenceType():{  TypeMirror type;}{  (    type = PrimitiveType() ( LOOKAHEAD(2) "[" "]" { type = this.typeResolver.getTypeUtils().getArrayType(type); } )+    |    ( type = ClassOrInterfaceType() ) ( LOOKAHEAD(2) "[" "]" { type = this.typeResolver.getTypeUtils().getArrayType(type); } )*  )  {    return type;  }}TypeMirror ClassOrInterfaceType():{	Token beginToken = null;	List<String> currentTypeNameParts = new LinkedList<>();	Token currentIdentifier;	TypeElement currentTypeElement;	DeclaredType currentType;	TypeMirror[] currentTypeArguments = new TypeMirror[0];}{  currentIdentifier = <IDENTIFIER> { beginToken = currentIdentifier; currentTypeNameParts.add(currentIdentifier.image); currentTypeElement = this.typeResolver.resolveType(new Range(beginToken, this.token), currentTypeNameParts); } [ LOOKAHEAD(2) currentTypeArguments = TypeArguments() ] { currentType = this.typeResolver.getTypeUtils().getDeclaredType(currentTypeElement, currentTypeArguments); currentTypeArguments = new TypeMirror[0]; }  ( LOOKAHEAD(2) "." currentIdentifier = <IDENTIFIER> { currentTypeNameParts.add(currentIdentifier.image); currentTypeElement = this.typeResolver.resolveType(new Range(beginToken, this.token), currentTypeNameParts); } [ LOOKAHEAD(2) currentTypeArguments = TypeArguments() ] { currentType = this.typeResolver.getTypeUtils().getDeclaredType(currentType, currentTypeElement, currentTypeArguments); currentTypeArguments = new TypeMirror[0]; } )*  {    return currentType;  }}TypeMirror[] TypeArguments():{	List<TypeMirror> typeArguments = new LinkedList< >();	TypeMirror currentTypeArg;}{  "<" currentTypeArg = TypeArgument() { typeArguments.add(currentTypeArg); } ( "," currentTypeArg = TypeArgument() { typeArguments.add(currentTypeArg); } )* ">"  {    return typeArguments.toArray(new TypeMirror[typeArguments.size()]);  }}TypeMirror TypeArgument():{  TypeMirror type = null;}{  (     type = ReferenceType()    |     "?" [ type = WildcardBounds() ] { if(type == null) { type = this.typeResolver.getTypeUtils().getWildcardType(null, null); } }  )  {    return type;  }}TypeMirror WildcardBounds():{	TypeMirror boundType;	TypeMirror wildcardType;}{  (     "extends" boundType = ReferenceType() { wildcardType = this.typeResolver.getTypeUtils().getWildcardType(boundType, null); }   |     "super" boundType = ReferenceType() { wildcardType = this.typeResolver.getTypeUtils().getWildcardType(null, boundType); } ) {    return wildcardType; }}TypeMirror PrimitiveType():{	TypeMirror primitiveType;}{  (    "boolean" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.BOOLEAN); }  |    "char" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.CHAR); }  |    "byte" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.BYTE); }  |    "short" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.SHORT); }  |    "int" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.INT); }  |    "long" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.LONG); }  |    "float" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.FLOAT); }  |    "double" { primitiveType = this.typeResolver.getTypeUtils().getPrimitiveType(TypeKind.DOUBLE); }  )  {    return primitiveType;  }}void ResultType():{}{  "void"|  Type()}NameInfo Name():/* * A lookahead of 2 is required below since "Name" can be followed * by a ".*" when used in the context of an "ImportDeclaration". */{	Token beginToken;	List<String > parts = new ArrayList<>();}{  <IDENTIFIER> { beginToken = this.token;parts.add(this.token.image); }  ( LOOKAHEAD(2) "." <IDENTIFIER> { parts.add(this.token.image);} )*  {    return new GenericNameInfo(new Range(beginToken, this.token), parts);  }}void NameList():{}{  Name() ( "," Name() )*}/* * Expression syntax follows. */void Expression():/* * This expansion has been written this way instead of: *   Assignment() | ConditionalExpression() * for performance reasons. * However, it is a weakening of the grammar for it allows the LHS of * assignments to be any conditional expression whereas it can only be * a primary expression.  Consider adding a semantic predicate to work * around this. */{}{  ConditionalExpression()  [    LOOKAHEAD(2)    (      AssignmentOperator() Expression()      |      "->" LambdaBody()      |      "::" [ TypeArguments() ] ( < IDENTIFIER > | "new" )    )  ]}void AssignmentOperator():{}{  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="}void ConditionalExpression():{}{  ConditionalOrExpression() [ "?" Expression() ":" Expression() ]}void ConditionalOrExpression():{}{  ConditionalAndExpression() ( "||" ConditionalAndExpression() )*}void ConditionalAndExpression():{}{  InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*}void InclusiveOrExpression():{}{  ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*}void ExclusiveOrExpression():{}{  AndExpression() ( "^" AndExpression() )*}void AndExpression():{}{  EqualityExpression() ( "&" EqualityExpression() )*}void EqualityExpression():{}{  InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*}void InstanceOfExpression():{}{  RelationalExpression() [ "instanceof" Type() ]}void RelationalExpression():{}{  ShiftExpression() ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression() )*}void ShiftExpression():{}{  AdditiveExpression() ( ( "<<" | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*}void AdditiveExpression():{}{  MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*}void MultiplicativeExpression():{}{  UnaryExpression() ( ( "*" | "/" | "%" ) UnaryExpression() )*}void UnaryExpression():{}{  ( "+" | "-" ) UnaryExpression()|  PreIncrementExpression()|  PreDecrementExpression()|  UnaryExpressionNotPlusMinus()}void PreIncrementExpression():{}{  "++" PrimaryExpression()}void PreDecrementExpression():{}{  "--" PrimaryExpression()}void UnaryExpressionNotPlusMinus():{}{  ( "~" | "!" ) UnaryExpression()|  LOOKAHEAD( CastLookahead() )  CastExpression()|  PostfixExpression()}// This production is to determine lookahead only.  The LOOKAHEAD specifications// below are not used, but they are there just to indicate that we know about// this.void CastLookahead():{}{  LOOKAHEAD(2)  "(" PrimitiveType()|  LOOKAHEAD("(" Type() "[")  "(" Type() "[" "]"|  "(" Type() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )}void PostfixExpression():{}{  PrimaryExpression() [ "++" | "--" ]}void CastExpression():{}{  LOOKAHEAD("(" PrimitiveType())  "(" Type() ")" UnaryExpression()|  "(" Type() ")" UnaryExpressionNotPlusMinus()}void PrimaryExpression():{}{  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*}void MemberSelector():{}{  "." TypeArguments() <IDENTIFIER>}void PrimaryPrefix():{}{  Literal()|  LOOKAHEAD( ( <IDENTIFIER> "." )* "this" )  ( <IDENTIFIER> "." )*  "this"|  "super"  (    "." <IDENTIFIER>    |    "::" [ TypeArguments() ] ( < IDENTIFIER > | "new" )  )|   // danson, added this part to support a construct like:   //   Buffer.super.setDirty(true);   // See Java Language Specification, 3rd edition, section 15.11.2.   LOOKAHEAD( ClassOrInterfaceType() "." "super" "." <IDENTIFIER> )   ClassOrInterfaceType() "." "super" "." <IDENTIFIER>|  "("  (    ")"    |      LOOKAHEAD( FormalParameter() )      LambdaParameters()      ")"    |      LOOKAHEAD( < IDENTIFIER > ",")      InferredLambdaParameters()      ")"    |      // This could still be a lambda expression, but this is handled after matching -> elsewhere      Expression()      ")"  )|  AllocationExpression()|  LOOKAHEAD( ResultType() "." "class" )  ResultType() "." "class"|  LOOKAHEAD (AnnotatedType() "::" )  AnnotatedType() "::"  [ TypeArguments() ] ( < IDENTIFIER > | "new" )|  Name()}void PrimarySuffix():{}{  LOOKAHEAD("." "super" ".")  "." "super"|  LOOKAHEAD("." "this")  "." "this"|  LOOKAHEAD(2)  "." AllocationExpression()|  LOOKAHEAD(3)  MemberSelector()|  "[" Expression() "]"|  "." <IDENTIFIER>|  Arguments()}void Literal():{}{  <INTEGER_LITERAL>|  <FLOATING_POINT_LITERAL>|  <CHARACTER_LITERAL>|  <STRING_LITERAL>|  BooleanLiteral()|  NullLiteral()}void BooleanLiteral():{}{  "true"|  "false"}void NullLiteral():{}{  "null"}void Arguments():{}{  "(" [ ArgumentList() ] ")"}void ArgumentList():{}{  Expression() ( "," Expression() )*}void AllocationExpression():{}{  LOOKAHEAD(2)  "new" PrimitiveType() ArrayDimsAndInits()|  "new" ClassOrInterfaceType() [ TypeArguments() ]    (      ArrayDimsAndInits()    |      Arguments() [ ClassOrInterfaceBody(false) ]    )}/* * The third LOOKAHEAD specification below is to parse to PrimarySuffix * if there is an expression between the "[...]". */void ArrayDimsAndInits():{}{  LOOKAHEAD(2)  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*|  ( "[" "]" )+ ArrayInitializer()}/* * Statement syntax follows. */void Statement():{}{  LOOKAHEAD(2)  LabeledStatement()|  AssertStatement()|  Block()|  EmptyStatement()|  StatementExpression() ";"|  SwitchStatement()|  IfStatement()|  WhileStatement()|  DoStatement()|  ForStatement()|  BreakStatement()|  ContinueStatement()|  ReturnStatement()|  ThrowStatement()|  SynchronizedStatement()|  TryStatement()}void AssertStatement():{}{  "assert" Expression() [ ":" Expression() ] ";"}void LabeledStatement():{}{  <IDENTIFIER> ":" Statement()}void Block():{}{  "{" ( BlockStatement() )* "}"}void BlockStatement():{}{  LOOKAHEAD( Modifiers() Type() <IDENTIFIER> )  LocalVariableDeclaration() ";"|  Statement()|  ClassOrInterfaceDeclaration(0)}void LocalVariableDeclaration():{}{  Modifiers() Type() VariableDeclarator() ( "," VariableDeclarator() )*}void EmptyStatement():{}{  ";"}void LambdaBody():{}{  (    Expression()    |    Block()  ) }void StatementExpression():/* * The last expansion of this production accepts more than the legal * Java expansions for StatementExpression.  This expansion does not * use PostfixExpression for performance reasons. */{}{  PreIncrementExpression()|  PreDecrementExpression()|  PrimaryExpression()  [    "++"  |    "--"  |    AssignmentOperator() Expression()  ]}void SwitchStatement():{}{  "switch" "(" Expression() ")" "{"    ( SwitchLabel() ( BlockStatement() )* )*  "}"}void SwitchLabel():{}{  "case" Expression() ":"|  "default" ":"}void IfStatement():/* * The disambiguating algorithm of JavaCC automatically binds dangling * else's to the innermost if statement.  The LOOKAHEAD specification * is to tell JavaCC that we know what we are doing. */{}{  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]}void WhileStatement():{}{  "while" "(" Expression() ")" Statement()}void DoStatement():{}{  "do" Statement() "while" "(" Expression() ")" ";"}void ForStatement():{}{  "for" "("  (      LOOKAHEAD(Modifiers() Type() <IDENTIFIER> ":")      Modifiers() Type() <IDENTIFIER> ":" Expression()    |     [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ]  )  ")" Statement()}void ForInit():{}{  LOOKAHEAD( Modifiers() Type() <IDENTIFIER> )  LocalVariableDeclaration()|  StatementExpressionList()}void StatementExpressionList():{}{  StatementExpression() ( "," StatementExpression() )*}void ForUpdate():{}{  StatementExpressionList()}void BreakStatement():{}{  "break" [ <IDENTIFIER> ] ";"}void ContinueStatement():{}{  "continue" [ <IDENTIFIER> ] ";"}void ReturnStatement():{}{  "return" [ Expression() ] ";"}void ThrowStatement():{}{  "throw" Expression() ";"}void SynchronizedStatement():{}{  "synchronized" "(" Expression() ")" Block()}void TryStatement():/* * Semantic check required here to make sure that at least one * finally/catch is present. */{}{  "try" Block()  ( "catch" "(" FormalParameter() ")" Block() )*  [ "finally" Block() ]}/* We use productions to match >>>, >> and > so that we can keep the * type declaration syntax with generics clean */void RUNSIGNEDSHIFT():{}{  ( LOOKAHEAD({ getToken(1).kind == GT &&                ((IrtToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )   ">" ">" ">"  )}void RSIGNEDSHIFT():{}{  ( LOOKAHEAD({ getToken(1).kind == GT &&                ((IrtToken)getToken(1)).realKind == RSIGNEDSHIFT} )  ">" ">"  )}/* Annotation syntax follows. */void Annotations():{}{	(        LOOKAHEAD("@")        Annotation()    )*}void Annotation():{}{   LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))   NormalAnnotation() |   LOOKAHEAD( "@" Name() "(" )   SingleMemberAnnotation() |   MarkerAnnotation()}void NormalAnnotation():{}{   "@" Name() "(" [ MemberValuePairs() ] ")"}void MarkerAnnotation():{}{  "@" Name()}void SingleMemberAnnotation():{}{  "@" Name() "(" MemberValue() ")"}void MemberValuePairs():{}{   MemberValuePair() ( "," MemberValuePair() )*}void MemberValuePair():{}{    <IDENTIFIER> "=" MemberValue()}void MemberValue():{}{  (   LOOKAHEAD("@")   Annotation()   |   MemberValueArrayInitializer()   |   ConditionalExpression() )}void  MemberValueArrayInitializer():{}{  "{" (MemberValue() ( LOOKAHEAD(2) "," MemberValue() )* [ "," ])? "}"}/* Annotation Types. */void AnnotationTypeDeclaration(int modifiers):{}{  "@" "interface" <IDENTIFIER> AnnotationTypeBody()}void AnnotationTypeBody():{}{  "{" ( AnnotationTypeMemberDeclaration() )* "}"}void AnnotationTypeMemberDeclaration():{   int modifiers;}{ modifiers = Modifiers() (   LOOKAHEAD(Type() <IDENTIFIER> "(")   Type() <IDENTIFIER> "(" ")" [ DefaultValue() ] ";"  |   ClassOrInterfaceDeclaration(modifiers)  |   EnumDeclaration(modifiers)  |   AnnotationTypeDeclaration(modifiers)  |   FieldDeclaration(modifiers) ) |   ( ";" )}void DefaultValue():{}{  "default" MemberValue()}