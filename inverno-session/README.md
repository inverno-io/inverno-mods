[redis]: https://redis.io/

# Session

The Inverno *session* module defines an API for managing sessions in an application.

A session is used to persist information when a specific client access an application and make them available between requests. A session is ephemeral by design and is set to expire some time in the future either after a period of inactivity or at a fixed time. It is uniquely identified by a session id initially generated by the application for a particular client which must securely store it and provide it in each subsequent request in order for the application to resolve the session.

The session id is usually an opaque identifier generated in a way that ensures that there is a negligible probability that the same value will be accidentally assigned to a different session. But, it can also be used to convey *stateless* session data that will then be stored on the client side in addition to the *stateful* data stored on the application side in which case the session identifier is no longer opaque and must at least guarantees integrity and optionally confidentiality.

In order to use the Inverno *session* module, we need to declare a dependency in the module descriptor:

```java
module io.inverno.example.app {
    requires io.inverno.mod.session;
}
```

And also declare that dependency in the build descriptor:

Using Maven:

```xml
<project>
    <dependencies>
        <dependency>
            <groupId>io.inverno.mod</groupId>
            <artifactId>inverno-session</artifactId>
        </dependency>
    </dependencies>
</project>
```

Using Gradle:

```groovy
compile 'io.inverno.mod:inverno-session:${VERSION_INVERNO_MODS}'
```

Then multiple optional dependencies can be included depending on the needs:

- a dependency to the *boot* module which provides the `Reactor` should be added if in-memory session stores are to be used.
- a dependency to the *redis* module and an implementation module should be added if [Redis][redis] session stores are to be used.
- a dependency to the *security-jose* module if JWT sessions are to be used.

```java
module io.inverno.example.app {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.redis.lettuce;
    requires io.inverno.mod.security.jose;
}
```

Using Maven:

```xml
<project>
    <dependencies>
        <dependency>
            <groupId>io.inverno.mod</groupId>
            <artifactId>inverno-boot</artifactId>
        </dependency>
        <dependency>
            <groupId>io.inverno.mod</groupId>
            <artifactId>inverno-redis-lettuce</artifactId>
        </dependency>
        <dependency>
            <groupId>io.inverno.mod</groupId>
            <artifactId>inverno-security-jose</artifactId>
        </dependency>
    </dependencies>
</project>
```

Using Gradle:

```groovy
compile 'io.inverno.mod:inverno-boot:${VERSION_INVERNO_MODS}'
compile 'io.inverno.mod:inverno-redis-lettuce:${VERSION_INVERNO_MODS}'
compile 'io.inverno.mod:inverno-security-jose:${VERSION_INVERNO_MODS}'
```

As stated before, the main purpose of sessions in an application is to be able to persist client specific data between requests. This can address several use cases such as authentication, shopping cart... Implementing sessions requires for the application to use a session store for creating and resolving sessions and for the client to provide the session id obtained from the initial request in each subsequent requests made to the application.

For instance, using an in-memory session store to store a counter, the application might look like:

```java
package io.inverno.example.app_session;

import io.inverno.core.annotation.Bean;
import io.inverno.core.annotation.Wrapper;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.concurrent.Reactor;
import io.inverno.mod.session.InMemoryBasicSessionStore;
import io.inverno.mod.session.Session;
import io.inverno.mod.session.SessionStore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
import reactor.core.publisher.Mono;

public class Main {

    @Wrapper
    @Bean( visibility = Bean.Visibility.PRIVATE )
    public static class SessionStoreWrapper implements Supplier<SessionStore<AtomicInteger, Session<AtomicInteger>>> {

        private final Reactor reactor;

        public SessionStoreWrapper(Reactor reactor) {
            this.reactor = reactor;
        }

        @Override
        public SessionStore<AtomicInteger, Session<AtomicInteger>> get() {
            return InMemoryBasicSessionStore.<AtomicInteger>builder(this.reactor).build();
        }
    }

    @Bean
    public static class SomeService {

        private final SessionStore<AtomicInteger, Session<AtomicInteger>> sessionStore;

        public SomeService(SessionStore<AtomicInteger, Session<AtomicInteger>> sessionStore) {
            this.sessionStore = sessionStore;
        }

        public String openSession() {
            return this.sessionStore
                .create()
                .map(Session::getId)
                .block();
        }

        public int incrementCounter(String sessionId) throws IllegalStateException {
            return this.sessionStore
                .get(sessionId)
                .switchIfEmpty(Mono.error(new IllegalStateException("Session does not exist or has expired")))
                .flatMap(session -> session.getData(AtomicInteger::new)
                    .flatMap(counter -> {
                        int counterValue = counter.incrementAndGet();
                        return session.save().thenReturn(counterValue);
                    })
                )
                .block();
        }

        public void closeSession(String sessionId) {
            this.sessionStore
                .get(sessionId)
                .flatMap(Session::invalidate)
                .block();
        }
    }

    public static void main(String[] args) {
        App_session appSession = Application.run(new App_session.Builder());

        try {
            String sessionId = appSession.someService().openSession();

            System.out.println(appSession.someService().incrementCounter(sessionId));
            System.out.println(appSession.someService().incrementCounter(sessionId));
            System.out.println(appSession.someService().incrementCounter(sessionId));

            appSession.someService().closeSession(sessionId);

            try {
                appSession.someService().incrementCounter(sessionId);
            } 
            catch(IllegalStateException e) {
                System.err.println(e.getMessage());
            }
        }
        finally {
            appSession.stop();
        }
    }
}
```

We can run the application which should display `1`, `2`, `3`, `Session does not exist or has expired`:

```plaintext
$ mvn inverno:run
...
2025-02-24 10:19:29,379 INFO  [main] i.i.t.a.App_session - Starting Module io.inverno.test.app_session...
2025-02-24 10:19:29,379 INFO  [main] i.i.m.b.Boot - Starting Module io.inverno.mod.boot...
2025-02-24 10:19:29,480 INFO  [main] i.i.m.b.Boot - Module io.inverno.mod.boot started in 100ms
2025-02-24 10:19:29,480 INFO  [main] i.i.t.a.App_session - Module io.inverno.test.app_session started in 104ms
2025-02-24 10:19:29,481 INFO  [main] i.i.c.v.Application - Application io.inverno.test.app_session started in 119ms
1
2
3
Session does not exist or has expired
2025-02-24 10:19:29,511 INFO  [main] i.i.t.a.App_session - Stopping Module io.inverno.test.app_session...
2025-02-24 10:19:29,512 INFO  [main] i.i.m.b.Boot - Stopping Module io.inverno.mod.boot...
2025-02-24 10:19:29,513 INFO  [main] i.i.m.b.Boot - Module io.inverno.mod.boot stopped in 0ms
2025-02-24 10:19:29,513 INFO  [main] i.i.t.a.App_session - Module io.inverno.test.app_session stopped in 1ms
```

Above example gives an overview of the session lifecycle which is first created in `SomeService#openSession()`, resolved and saved after initializing and/or updating session data in `SomeService#incrementCounter(String)` and finally invalidated in `SomeService#closeSession(String)`. Session data is strongly typed which allows to validate the code statically at compile time.

> It is important to notice that the session must be saved in order for session data to be persisted. This actually depends on the session store implementation: although this is a must when using an external data store like Redis or a RDBMS for obvious reasons, an in-memory session store may be more permissive, for instance we could have initialized the session data once in `SomeService#openSession()` to have them set in the actual stored session and then simply resolve and update them in `SomeService#incrementCounter(String)` because, once session data is initialized, `Session#getData()` will always return the same instance. In practice, you should always assume that session data and the session in general must be saved explicitly at the end of a request processing to keep session consistent.

## Session store

The `SessionStore` manages sessions and their lifecycle in an application, it is used to create, resolve, save and invalidate sessions. In practice, it is meant to be used in intermediary services (e.g. exchange interceptors in a Web application) that implicitly create, resolve and provide the session to the actual application services.

The following example shows how a session store is used to create, resolve, save and remove a session:

```java
SessionStore<Map<String, String>, Session<Map<String, String>>> sessionStore = ...

Session<Map<String, String>> newSession = sessionStore.create().block();                           // 1
String sessionId = newSession.getId();

Session<Map<String, String>> resolvedSession = sessionStore                                        // 2
    .get(sessionId)
    .switchIfEmpty(Mono.error(new IllegalStateException("Session does not exist or has expired"))) // 3
    .block();

Map<String, String> sessionData = resolvedSession.getData(HashMap::new).block();                   // 4
sessionData.put("someAttribute", "someValue");                                                     // 5

sessionStore.save(resolvedSession).block();                                                        // 6

sessionStore.remove(sessionId).block();                                                            // 7
```

1. A new session is created by generating a unique session id and storing the newly created session in a data store. From there the session store monitors the session which is set to expire either after a period of inactivity or at a specific time in the future.
2. Resolve the existing session identified by the provided session id.
3. A session might not exist for the specified session id either because the provided session id is invalid or because the session has expired.
4. Session data are retrieved from the session, they can be initialized when missing by specifying a supplier.
5. Session data can then be updated.
6. The session must be stored for the data or any other modification to be persisted.
7. Eventually the session is removed/invalidated.

The session and its data are *independent* in a sense that they can be resolved independently, the `Session` is relevant when there is a need to update metadata such as expiration settings, save (including data) or invalidate the session, but when data are only needed for read-only, they can be directly resolved:

```java
Map<String, String> sessionData = sessionStore.getData(sessionId).block();
String someAttributeValue = sessionData.get("someAttribute");
```

This allows to optimize session access with some implementations, but it is important to remember that any update to the session data thus obtained might not be persisted and that the session last accessed time will not be updated as well.

A session identifier is a string generated in such a way that there is a negligible probability that the same value will be accidentally assigned to a different session. Session store implementations delegates the generation of session ids to a `SessionIdGenerator`. The API provides a simple implementation generating UUID optionally encoded in Base64:

```java
SessionIdGenerator<Map<String, String>, Session<Map<String, String>>> base64UUIDSessionIdGenerator = SessionIdGenerator.uuid(); // encoded in Base64 by default

SessionIdGenerator<Map<String, String>, Session<Map<String, String>>> uuidSessionIdGenerator = SessionIdGenerator.uuid(false);  // not encoded in Base64
```

> A session identifier is usually opaque, but it can also be used to convey *stateless* session data that are then stored client side. This is the case for JWT session stores that uses JWTs as session identifiers.

The session API provides several `SessionStore` implementations for storing basic or JWT sessions in-memory or in a Redis data store: `InMemoryBasicSessionStore`, `RedisBasicSessionStore`, `InMemoryJWTSessionStore` and `RedisJWTSessionStore`.

In the case of basic session stores, sessions are stored exclusively in a data store on the application side. In the case of JWT session stores, sessions are stored in both the session id on the client side and in a data store on the application side.

## Session

A `Session` is created or resolved from a `SessionStore`, unlike the `SessionStore` which is not meant to be manipulated directly in the application, the `Session` is directly exposed in the application. It gives access to session data and metadata such as the session id and expiration settings, it also exposes session lifecycle operations to refresh the session id and save or invalidate the session.

The session lifecycle is as follows:

1. On creation an *empty* session is persisted in the session store. On resolution, a local session is loaded if the session has not expired.
2. From there the session can be used and updated in the application.
3. At the end of the processing of client request, the session must be saved to persist any updates made to the local session.
4. Eventually the session expires or is invalidated and removed from the session store.

> It is important to understand that when interacting with a session, changes are not persisted on the fly implicitly, the local session must be saved explicitly in order to persist any change in the session store. This also means that concurrent access to sessions is not supported and might lead to data being overwritten, but that is not the purpose of session anyway. Using an RDBMS or any data store supporting transactions is the recommended way to avoid conflicting updates in the presence of concurrent access.

It exposes two session identifiers: the original session id which is the one that was resolved with the session or `null` for a newly created session and the actual session id which only differs from the original one when refreshed by the session either explicitly by invoking `Session#refreshId(true)` or implicitly if needed when saving the session. 

Considering a newly created session:

```java
SessionStore<SessionData, Session<SessionData>> sessionStore = ...
Session<SessionData> session = sessionStore.create().block();

String originalSessionId = session.getOriginalId(); // null because this is a new session
String sessionId = session.getId();                 // the session identifier
```

Considering an existing session:

```java
SessionStore<SessionData, Session<SessionData>> sessionStore ...
Session<SessionData> session = sessionStore.get("123456").block();

String originalSessionId = session.getOriginalId(); // the original session id
String sessionId = session.getId();                 // same as original session id since it was not refreshed
```

Considering an existing session for which the session id is explicitly refreshed:

```java
SessionStore<SessionData, Session<SessionData>> sessionStore ...
Session<SessionData> session = sessionStore.get("123456").block();

session.refreshId(true).block();

String originalSessionId = session.getOriginalId(); // the original session id
String sessionId = session.getId();                 // different from the original session id since it was refreshed
```

A session id is refreshed in order to limit replay attacks or when using some implementations that stores data inside the session id when they have been updated. The `Session#refreshId(boolean)` method allows to force session id refresh as in above example or to only do it when needed, typically in case data stored in the session id has been modified. `Session#getOriginalId()` and `Session#getId()` can be used to determine whether the session id was indeed refreshed.

A session is ephemeral by design and set to expire some time in the future either after a period of inactivity or at a specific time. These expiration settings are initialized by the session store when the session is created, they are exposed on the session instance which also allows to change them during the lifetime of the session.

In case the session is set to expire after a period of inactivity the maximum inactive interval should be set. The session expires when the last accessed time happened before the current time minus the interval, the actual expiration time is returned by `Session#getExpirationTime()` which is calculated from the last accessed time and the maximum inactive interval.

```java
Session<SessionData> session = ...

long lastAccessedTime = session.getLastAccessedTime();
Long maxInactiveInterval = session.getMaxInactiveInterval(); // null when the session is set to expire at a specific time in the future

long expirationTime = session.getExpirationTime();           // lastAccessedTime + maxInactiveInterval
```

By default, a session store should set a new session to expire after `Session#DEFAULT_MAX_INACTIVE_INTERVAL = 1800000L` milliseconds (i.e. 30 minutes) of inactivity, but be aware that this is implementation specific. The maximum inactive interval can be changed on a particular session as follows:

```java
session.setMaxInactiveInterval(300000L); // set session to expire after 5 minutes of inactivity
```

Above code overrides specific expiration time if any was set.

In case the session is set to expire at a specific time in the future, the maximum inactive interval is `null`.

```java
Session<SessionData> session = ...

session.setExpirationTime(System.currentTimeMillis() + 600000L); // expires in 10 minutes
long expirationTime = session.getExpirationTime();               // the expiration time that was set

Long maxInactiveInterval = session.getMaxInactiveInterval();     // null since explicit expiration time has been set
```

As when setting the maximum inactive interval, setting an explicit expiration time overrides the maximum inactive interval which is then set to `null`.

The `Session` also gives access to the session data which is strongly typed and *independent* of the session, it is not automatically resolved along with the session and has to be resolved and set on the session:

```java
Session<SessionData> session = ...

SessionData sessionData = session.getData(SessionData::new).block(); // create data when missing

String someData = sessionData.getSomeData();                         // update data
sessionData.setSomeData("Updated data");

session.setData(sessionData);                                        // set data explicitly

session.save().block();                                              // save the session
```

When a session is saved the session store must determine whether data should be saved, so basically whether they have been modified. The behaviour depends on the implementation, but in general it is fair to assume that data will be saved if they have been resolved and then explicitly set by invoking `Session#setData(Object)`. The API provides the `SessionDataSaveStrategy` to influence this behaviour, it defines a single method `SessionDataSaveStrategy#getAndSetSaveState(Object, boolean)` which must determine when the provided session data has been modified and requires to be saved. The API provides two default implementations: 

- `SessionDataSaveStrategy.onSetOnly()` which indicates that session data shall only be saved when `Session#setData(Object)` was invoked (i.e. `getAndSetSaveState` always returns `false`).
- `SessionDataSaveStrategy.onGet()` which indicates that session data shall be saved whenever they have been resolved from the session using `Session#getData()` (i.e. `getAndSetSaveState` always returns `true`).

The default behaviour for most session store implementations is to rely on `SessionDataSaveStrategy#onGet()` to make sure resolved session data are saved when `Session#save()` is invoked with the consequence that they are always saved even if they were not modified. This can be optimized by providing adhoc implementations for specific session data types that precisely detect modifications (this typically requires to be able to define some state in the session data which is set when data are modified).

> It is not possible to rely on `Object#equals(Object)` to detect changes in the session data because there is only one session data instance, there is no original instance to compare it to. It would have been possible to achieve this it by duplicating the session data instance, but this is not always possible and might have a significant impact on memory which is why the `SessionDataSaveStrategy` was introduced.

A session can be invalidated during the processing of a request by invoking `Session#invalidate()` as follows:

```java
Session<SessionData> session = ...

session.invalidate().block();
```

After being invalidated a session is removed from the session store and can no longer be saved or used.

The session API differentiates two kinds of session:

- **Basic session** using opaque identifiers and storing session data in a data store on application side.
- **JWT session** using JWT identifiers and storing session data in both the session id kept on the client side and a data store on application side.

### Basic session

A basic session uses an opaque session id only used to resolve the session from the session store on application side. The API provides two implementations: `InMemoryBasicSessionStore` and `RedisBasicSessionStore`. They both rely on basic `SessionIdGenerator`, typically the `SessionIdGenerator.uuid()`, although custom implementations can be specified as well.

#### In-memory Basic session store

The `InMemoryBasicSessionStore` implementation stores session in-memory in a concurrent map, it is suited for simple or test applications that do not require to have sessions shared across multiple nodes. It requires the `Reactor` to schedule the session clean task removing expired sessions.

```java
Reactor reactor = ...

InMemoryBasicSessionStore<SessionData> sessionStore = InMemoryBasicSessionStore
    .<SessionData>builder(reactor, SessionIdGenerator.uuid(true))        // generate Base64 encoded UUID as session id
    .cleanPeriod(InMemoryBasicSessionStore.DEFAULT_CLEAN_PERIOD)         // 5 minutes
    .maxInactiveInterval(Session.DEFAULT_MAX_INACTIVE_INTERVAL)          // 30 minutes
    .expireAfterPeriod(Session.DEFAULT_MAX_INACTIVE_INTERVAL)            // overrides max inactive interval which is set by default
    .build();
```

#### Redis Basic session store

The `RedisBasicSessionStore` implementation stores sessions in a [Redis][redis] data store, it is suited when there is a need to share sessions across multiple nodes. It requires a `RedisClient` for storing sessions in the Redis data store, an `ObjectMapper` and the session data type for deserializing/serializing session data from/to the Redis data store.

```java
RedisClient<String, String> redisClient = ...
ObjectMapper mapper = ...

RedisBasicSessionStore<SessionData> sessionStore = RedisBasicSessionStore.<SessionData>builder(redisClient, mapper, SessionData.class, SessionIdGenerator.uuid())
    .keyPrefix(RedisBasicSessionStore.DEFAULT_KEY_PREFIX)
    .maxInactiveInterval(Session.DEFAULT_MAX_INACTIVE_INTERVAL)                 // 30 minutes
    .expireAfterPeriod(Session.DEFAULT_MAX_INACTIVE_INTERVAL)                   // overrides max inactive interval which is set by default
    .sessionDataSaveStrategy(SessionDataSaveStrategy.onSetOnly())               // only save data when setData() is explicitly invoked on the session
    .build();
```

When not specified, the default `SessionDataSaveStrategy` is `SessionDataSaveStrategy#onGet()` which means session data are saved whenever they are resolved. 

Session are automatically expired by Redis using `PEXPIRE` or `PEXPIREAT` set on the session Redis key.

> Note that a two minutes buffer is used to make sure sessions can still be accessed at the limits.

### JWT session

Unlike the basic session, which uses opaque session id, a JWT session uses a JWT as session id which allows to store part of the session data in the session id itself and keep it on the client side. The main session reference is still kept in a data store on the application side and used in the end to determine whether a session has expired or has been invalidated, protecting against replay attacks.

A JWT session defines two kinds of session data which are both strongly typed:

- regular *stateful* data stored application side in a data store, resolved and set using `JWTSession#getData()` and `JWTSession#setData(Object)`.
- *stateless* data stored in the JWT session id stored client side, get and set using `JWTSession#getStatelessData()` and `JWTSession#setStatelessData(Object)`.

Since stateless data are stored in the session id, any change should trigger a refresh of the session id. As for regular session data, implementations can rely on `SessionDataSaveStrategy` to determine whether a refresh is required. Considering the side effects a refresh of the session id might induce the safest and default approach chosen in the session API implementations is to use the `SessionDataSaveStrategy.onSetOnly()` strategy which requires to explicitly invoke `JWTSession#setStatelessData(Object)` to trigger the session refresh on save.

JWT sessions enables interesting setups where session data can be stored entirely client side leaving only a reference on the application side optimizing resource usage on the server.

```java
JWTSessionStore<Void, AuthenticationData> sessionStore = ...

JWTSession<Void, AuthenticationData> jwtSession = sessionStore.create().block();

jwtSession.setStatelessData(new AuthenticationData("jsmith"));

jwtSession.save().block(); // trigger refresh session id since stateless data has been set

jwtSession.getId(); // JWT containing authentication data
```

Note that such setup is particularly suited when session data barely change during the lifetime of the session which is typically the case of authentication data.

The API provides two implementations: `InMemoryJWTSessionStore` and `RedisJWTSessionStore` which rely on a `JWTSessionIdGenerator` to generate JWT session identifiers.

#### JWTSessionIdGenerator

A `JWTSessionIdGenerator` is used to generate JWT session identifiers containing session metadata, namely expiration settings, and stateless session data as JWT claims. The API allows to create two kinds of JWT session id generator: a JWS generator which guarantees integrity and a JWE generator which guarantees both integrity and confidentiality.

A JWS `JWTSessionIdGenerator` can be obtained as follows:

```java
JWKService jwkService = ...
JWTService jwtService = ...

String keyId = UUID.randomUUID().toString();

jwkService.oct().generator()
    .keyId(keyId)
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .generate()
    .map(JWK::trust)
    .flatMap(jwkService.store()::set)
    .block();

JWTSessionIdGenerator<SessionData, StatelessSessionData> jwtsSessionIdGenerator = JWTSessionIdGenerator.jws(jwtService, headers -> headers
    .keyId(keyId)
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
);
```

A JWE `JWTSessionIdGenerator` can be obtained as follows:

```java
JWKService jwkService = ...
JWTService jwtService = ...

String keyId = UUID.randomUUID().toString();

jwkService.ec().generator()
    .keyId(keyId)
    .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
    .curve(ECCurve.P_256.getCurve())
    .generate()
    .map(JWK::trust)
    .flatMap(jwkService.store()::set)
    .block();

JWTSessionIdGenerator<SessionData, StatelessSessionData> jwteSessionIdGenerator = JWTSessionIdGenerator.jwe(jwtService, header -> header
    .keyId(keyId)
    .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
    .encryptionAlgorithm(OCTAlgorithm.A256GCM.getAlgorithm())
);
```

#### In-memory JWT session store

The `InMemoryJWTSessionStore` stores *stateful* session data in-memory in a concurrent map, it is suited for simple or test applications that do not require to have sessions shared across multiple nodes. It requires a `JWTSessionIdGenerator` for generating JWT session ids, the `Reactor` to schedule the session clean task removing expired sessions, an `ObjectMapper` and the *stateless* session data type for deserializing *stateless* session data from the JWT claim.

```java
Reactor reactor = ...
ObjectMapper mapper = ...
JWTSessionIdGenerator<SessionData, StatelessSessionData> jwtSessionIdGenerator = ...

InMemoryJWTSessionStore<SessionData, StatelessSessionData> jwtSessionStore = InMemoryJWTSessionStore.builder(
        jwtSessionIdGenerator,
        reactor,
        mapper,
        StatelessSessionData.class
    )
    .cleanPeriod(InMemoryBasicSessionStore.DEFAULT_CLEAN_PERIOD)           // 5 minutes
    .maxInactiveInterval(Session.DEFAULT_MAX_INACTIVE_INTERVAL)            // 30 minutes
    .expireAfterPeriod(Session.DEFAULT_MAX_INACTIVE_INTERVAL)              // overrides max inactive interval which is set by default
    .statelessSessionDataSaveStrategy(SessionDataSaveStrategy.onSetOnly()) // must be onSetOnly() by default
    .build();
```

It uses a `SessionDataSaveStrategy` to determine whether the JWT session id must be refreshed, basically when *stateless* data has changed. This is set to `SessionDataSaveStrategy.onSetOnly()` by default to avoid undesirable side effects in some situations where session id refresh is triggered multiple times within the same transaction using `SessionDataSaveStrategy.onGet()` strategy.

> `SessionDataSaveStrategy.onSetOnly()` is the safest approach, a custom strategy, taking the stateless session type specificities into account, can be provided to avoid having to invoke `JWTSession#setStatelessData(Object)` explicitly.

#### Redis JWT session store

The `RedisJWTSessionStore` stores *stateful* session data in a [Redis][redis] data store, it is suited when there is a need to share sessions across multiple nodes. It requires a `RedisClient` for storing sessions in the Redis data store, an `ObjectMapper` and the *stateful* and *stateless* session data types for deserializing/serializing *stateful* session data from/to the Redis data store and deserializing *stateless* session data from the JWT claim.

```java
RedisClient<String, String> redisClient = ...
ObjectMapper mapper = ...
JWTSessionIdGenerator<SessionData, StatelessSessionData> jwtSessionIdGenerator = ...

RedisJWTSessionStore<SessionData, StatelessSessionData> jwtSessionStore = RedisJWTSessionStore.builder(
        jwtSessionIdGenerator,
        redisClient,
        mapper,
        SessionData.class,
        StatelessSessionData.class
    )
    .keyPrefix(RedisJWTSessionStore.DEFAULT_KEY_PREFIX)
    .maxInactiveInterval(Session.DEFAULT_MAX_INACTIVE_INTERVAL)            // 30 minutes
    .expireAfterPeriod(Session.DEFAULT_MAX_INACTIVE_INTERVAL)              // overrides max inactive interval which is set by default
    .sessionDataSaveStrategy(SessionDataSaveStrategy.onSetOnly())          // only save stateful data when setData() is explicitly invoked on the session
    .statelessSessionDataSaveStrategy(SessionDataSaveStrategy.onSetOnly()) // must be onSetOnly() by default
    .build();
```

When not specified, the default `SessionDataSaveStrategy` for *stateful* session data is `SessionDataSaveStrategy#onGet()` which means *stateful* session data are saved whenever they are resolved and the default `SessionDataSaveStrategy` for *stateless* session data is `SessionDataSaveStrategy#onSetOnly()` to avoid undesirable side effects in some situations where session id refresh is triggered multiple times within the same transaction using `SessionDataSaveStrategy.onGet()` strategy.

Session are automatically expired by Redis using `PEXPIRE` or `PEXPIREAT` set on the session Redis key.

> Note that a two minutes buffer is used to make sure sessions can still be accessed at the limit.