/*
 * Copyright 2025 Jeremy KUHN
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.inverno.mod.session;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.function.Supplier;
import reactor.core.publisher.Mono;

/**
 * <p>
 * A session provides a way to persist data across multiple requests.
 * </p>
 *
 * <p>
 * A session is set to expire after a specific period of inactivity or at a specific time. The maximum inactive interval or the expiration time are specified on session creation and can be updated
 * during the lifetime of the session. A session lasts as long as it is not expired and not explicitly invalidated.
 * </p>
 *
 * <p>
 * A session is uniquely identify by an id generated by a {@link SessionIdGenerator}. This id is used to resolve the session between requests from a {@link SessionStore}. It can be refreshed during
 * the lifetime of the session.
 * </p>
 *
 * <p>
 * A session may hold strongly typed data stored in the {@link SessionStore}, but this is not mandatory. A session can exist and can be resolved independently of the data it may or may not contain.
 * </p>
 * 
 * @author <a href="mailto:jeremy.kuhn@inverno.io">Jeremy Kuhn</a>
 * @since 1.13
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public interface Session<A> {

	/**
	 * The default maximum inactive interval in milliseconds: {@code 1800000} (i.e. 30 minutes).
	 */
	long DEFAULT_MAX_INACTIVE_INTERVAL = 1800000L;

	/**
	 * <p>
	 * Returns the original session identifier.
	 * </p>
	 *
	 * <p>
	 * The original session id is the value that was used to resolve an existing session or {@code null} for a new session.
	 * </p>
	 *
	 * @return the original session id for an existing session or {@code null} if the session is new
	 */
	@JsonIgnore
	String getOriginalId();

	/**
	 * <p>
	 * Returns the session unique identifier.
	 * </p>
	 *
	 * @return a unique identifier
	 */
	@JsonProperty("id")
	String getId();

	/**
	 * <p>
	 * Returns the session creation time in milliseconds.
	 * </p>
	 *
	 * @return the session creation time
	 */
	@JsonProperty("creationTime")
	long getCreationTime();

	/**
	 * <p>
	 * Returns the session last accessed time in milliseconds.
	 * </p>
	 *
	 * <p>
	 * The last accessed time shall only be updated when saving a session, it is not updated when the session is resolved and as a result the last accessed time effectively corresponds to the last
	 * saved time.
	 * </p>
	 *
	 * @return the session last accessed time
	 */
	@JsonProperty("lastAccessedTime")
	long getLastAccessedTime();

	/**
	 * <p>
	 * Sets the maximum inactive interval in milliseconds.
	 * </p>
	 *
	 * <p>
	 * The maximum inactive interval replaces the expiration time if any was set.
	 * </p>
	 *
	 * @param maxInactiveInterval a maximum inactive interval in milliseconds
	 */
	void setMaxInactiveInterval(long maxInactiveInterval);

	/**
	 * <p>
	 * Returns the maximum inactive interval in milliseconds.
	 * </p>
	 *
	 * <p>
	 * The maximum inactive interval is {@code null} when a specific expiration time was set.
	 * </p>
	 *
	 * @return the maximum inactive interval in milliseconds or {@code null} if the session is set to expire at a specific time
	 */
	@JsonProperty("maxInactiveInterval")
	Long getMaxInactiveInterval();

	/**
	 * <p>
	 * Sets the session expiration time in milliseconds.
	 * </p>
	 *
	 * <p>
	 * The expiration time replaces the maximum inactive interval if any was set.
	 * </p>
	 *
	 * @param expirationTime an expiration time in milliseconds
	 */
	void setExpirationTime(long expirationTime);

	/**
	 * <p>
	 * Returns the time in milliseconds at which the session is set to expire.
	 * </p>
	 *
	 * <p>
	 * This method calculates and returns the actual time when the session will expire when a maximum inactive interval is set, otherwise it returns the specific expiration time that was set.
	 * </p>
	 *
	 * @return the session expiration time
	 */
	@JsonProperty("expirationTime")
	long getExpirationTime();

	/**
	 * <p>
	 * Resolves the session data.
	 * </p>
	 *
	 * @return a mono resolving session data or an empty mono if none exist in the session
	 */
	@JsonIgnore
	Mono<A> getData();

	/**
	 * <p>
	 * Resolves the session data or creates them using the specified supplier if none exist in the session.
	 * </p>
	 *
	 * @param supplier a session data supplier
	 *
	 * @return a mono resolving or creating session data
	 */
	@JsonIgnore
	default Mono<A> getData(Supplier<A> supplier) {
		return this.getData().switchIfEmpty(Mono.fromSupplier(() -> {
			A sessionData = supplier.get();
			this.setData(sessionData);
			return sessionData;
		}));
	}

	/**
	 * <p>
	 * Sets the session data.
	 * </p>
	 *
	 * @param sessionData the session data
	 */
	void setData(A sessionData);

	/**
	 * <p>
	 * Determines whether the session has expired.
	 * </p>
	 *
	 * @return true if the session has expired, false otherwise
	 */
	@JsonProperty("expired")
	boolean isExpired();

	/**
	 * <p>
	 * Determines whether the session has been invalidated.
	 * </p>
	 *
	 * @return true if the session has been invalidated, false otherwise
	 */
	@JsonProperty("invalidated")
	boolean isInvalidated();

	/**
	 * <p>
	 * Determines whether the session is new.
	 * </p>
	 *
	 * @return true if this is a new session, false otherwise
	 */
	@JsonProperty("new")
	default boolean isNew() {
		return this.getOriginalId() == null;
	}

	/**
	 * <p>
	 * Refreshes the session id only if it is stale.
	 * </p>
	 *
	 * @return a mono that emits the new session identifier or an empty mono if the identifier did not need to be refreshed
	 */
	default Mono<String> refreshId() {
		return this.refreshId(false);
	}

	/**
	 * <p>
	 * Refreshes the session id.
	 * </p>
	 *
	 * @param force true to force refresh, false to only refresh the id if it is stale
	 *
	 * @return a mono that emits the new session identifier or an empty mono if the identifier did not need to be refreshed
	 */
	Mono<String> refreshId(boolean force);

	/**
	 * <p>
	 * Saves the session.
	 * </p>
	 *
	 * <p>
	 * This basically updates the session last accessed time and any updates to expiration settings.
	 * </p>
	 *
	 * <p>
	 * Assuming session data were resolved, whether they are saved is implementation specific. This actually widely depends on the session store and the strategy chosen to optimize underlying data
	 * store usage. Implementors must however at least guarantee that data that are explicitly set on a session using {@link #setData(Object)} are saved.
	 * </p>
	 *
	 * @return a mono which completes when the session is saved
	 */
	Mono<Void> save();

	/**
	 * <p>
	 * Invalidates the session.
	 * </p>
	 *
	 * @return a mono which completes when the session is invalidated
	 */
	Mono<Void> invalidate();
}
